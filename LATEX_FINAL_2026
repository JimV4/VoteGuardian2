\documentclass[12pt,a4paper]{report}

% \usepackage[utf8]{inputenc}
\usepackage{float}
% \usepackage[LGR,T1]{fontenc}        % LGR για ελληνικά, T1 για αγγλικά
% \usepackage[greek,english]{babel}
% \usepackage{lmodern}                
\renewcommand{\rmdefault}{lmr}      
\usepackage{listings}
\usepackage{xcolor}


% \usepackage{polyglossia}

\lstset{
  basicstyle=\ttfamily\small,
  backgroundcolor=\color{gray!10},
  keywordstyle=\color{blue}\bfseries,
  stringstyle=\color{green!50!black},
  commentstyle=\color{gray}\itshape,
  showstringspaces=false,
  breaklines=true,
  frame=single,
  tabsize=2
}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{geometry}
\geometry{margin=1in}

\usepackage{fontspec,polyglossia}

\usepackage[backend=biber,style=numeric]{biblatex}
\addbibresource{references.bib}



% Set Greek as main language
\setmainlanguage[variant=modern]{greek}
\setotherlanguage{english}

% Fonts
\setmainfont{Times New Roman}
\newfontfamily\greekfont{Arial}[Script=Greek]
\newfontfamily\englishfont{Arial}[Script=Latin]

\usepackage{tikz}                   % <-- MUST include TikZ package


\usetikzlibrary{trees} 
\begin{document}

% ------------------ Title Page -------------------
\begin{titlepage}
    \centering
    
    \vspace*{1cm}
    {\Large National Technical University of Athens \\}
    {\large School of Electrical and Computer Engineering \\}
    {\large Computer Science Laboratory \\}
    
    \vfill
    
    {\LARGE \textbf{Student Voting DApp on Midnight Blockchain} \\[1.5cm]}
    
    {\Large \textbf{DIPLOMA THESIS} \\[1.5cm]}
    
    {\Large VASSILIOU DIMITRIOS \\}
    
    \vfill
    
    {\large September 2025}
\end{titlepage}

\tableofcontents
\newpage

% ------------------ First Chapter Introcution -------------------
\chapter{Εισαγωγή}

Η τεχνολογία blockchain είναι ένα σύστημα κατανεμημένων κόμβων που επιτρέπει την ασφαλή,
διαφανή και ανθεκτική σε παραβιάσεις καταγραφή ψηφιακών συναλλαγών. Σε αντίθεση με τις
παραδοσιακές κεντρικές βάσεις δεδομένων, ένα blockchain διατηρείται συλλογικά
από ένα δίκτυο συμμετεχόντων, εξαλείφοντας την ανάγκη για μια ενιαία αξιόπιστη
αρχή.

Κάθε μπλοκ στην αλυσίδα περιέχει μια ομάδα συναλλαγών, μια χρονική σήμανση και
ένα κρυπτογραφικό hash του προηγούμενου μπλοκ. Μόλις προστεθούν οι πληροφορίες, είναι εξαιρετικά
δύσκολο να τροποποιηθούν χωρίς τη συναίνεση του δικτύου. \cite{surveyonblockchain}

Κύρια χαρακτηριστικά του blockchain περιλαμβάνουν:
\begin{itemize}
    \item \textbf{Αποκεντροποίηση} -- Τα δεδομένα αποθηκεύονται και επαληθεύονται σε πολλαπλούς κόμβους, αντί για έναν κεντρικό server.
    \item \textbf{Διαφάνεια} -- οι συναλλαγές είναι ορατές σε όλους τους συμμετέχοντες
    στο δίκτυο.
    \item \textbf{Ασφάλεια} -- κρυπτογραφικοί μηχανισμοί το καθιστούν ανθεκτικό σε
    απάτες και παραβιάσεις.
    \item \textbf{μηχανισμοί Consensus} -- όπως οι Proof of Work και Proof of
    Stake, οι οποίοι εξασφαλίζουν συμφωνία μεταξύ των συμμετεχόντων.
\end{itemize}

Η τεχνολογία blockchain, που εισήχθη αρχικά με το Bitcoin το 2008 ως η ραχοκοκαλιά του ψηφιακού
νομίσματος, έχει εξελιχθεί από τότε πολύ πέρα από τα κρυπτονομίσματα.
Τώρα εφαρμόζεται σε τομείς όπως η διαχείριση της εφοδιαστικής αλυσίδας, η υγειονομική περίθαλψη,
η επαλήθευση ταυτότητας και τα συστήματα ψηφοφορίας.
Η παρούσα διατριβή επικεντρώνεται στο \textit{Midnight}, μια πλατφόρμα blockchain που έχει σχεδιαστεί με
ιδιαίτερη έμφαση στην ασφάλεια, την ιδιωτικότητα των χρηστών και τη διαφάνεια. Αξιοποιώντας
προηγμένες τεχνικές κρυπτογράφησης, ιδίως αποδείξεις μηδενικής γνώσης, το Midnight
επιτρέπει στους συμμετέχοντες να αποδεικνύουν την εγκυρότητα των πληροφοριών χωρίς να αποκαλύπτουν τα
υποκείμενα δεδομένα. Αυτά τα χαρακτηριστικά καθιστούν το Midnight ιδανική βάση για την
ανάπτυξη μιας αποκεντρωμένης εφαρμογής ψηφοφορίας, όπου η εμπιστοσύνη, η εμπιστευτικότητα
και η επαληθευσιμότητα είναι βασικές απαιτήσεις.

% ------------------ Motivation -------------------

\section{Κίνητρο}
Η ψηφοφορία είναι μια θεμελιώδης διαδικασία που ενσωματώνει την πρακτική εφαρμογή της δημοκρατίας. 
Χρησιμεύει ως μηχανισμός λήψης αποφάσεων σε ένα ευρύ φάσμα πλαισίων, συμπεριλαμβανομένων 
των κυβερνητικών εκλογών, των επαγγελματικών ενώσεων, των κοινωνικών οργανώσεων και των εκπαιδευτικών  ιδρυμάτων. Η ακεραιότητα της διαδικασίας ψηφοφορίας είναι επομένως κρίσιμη, καθώς διασφαλίζει ότι τα αποτελέσματα αντικατοπτρίζουν την πραγματική βούληση των συμμετεχόντων. Για το λόγο αυτό, ένα σύστημα ψηφοφορίας πρέπει να είναι διαφανές, δίκαιο και ανώνυμο, ώστε να προστατεύεται η ταυτότητα και η ιδιωτικότητα των συμμετεχόντων.
Τα παραδοσιακά συστήματα ψηφοφορίας, είτε σε χαρτί είτε ηλεκτρονικά, συχνά αντιμετωπίζουν σημαντικές 
προκλήσεις. Τα χαρτιά ψηφοφορίας είναι ευάλωτα σε ανθρώπινα λάθη και χειραγώγηση, ενώ 
τα κεντρικά ηλεκτρονικά συστήματα μπορεί να είναι ευάλωτα σε κυβερνοεπιθέσεις, παραβιάσεις και διαρροές δεδομένων . Στο πλαίσιο των φοιτητικών εκλογών, τα συμβατικά ηλεκτρονικά συστήματα απαιτούν συνήθως έναν κεντρικό διακομιστή και μια βάση δεδομένων όπου αποθηκεύονται τα προσωπικά στοιχεία και οι ψήφοι των φοιτητών .Αυτό δημιουργεί μια κατάσταση όπου οι φοιτητές πρέπει να αποκαλύψουν τις επιλογές τους στο ίδρυμα, γεγονός που θέτει σε κίνδυνο την αρχή της ανωνυμίας των ψηφοφόρων και μπορεί να υπονομεύσει την εμπιστοσύνη στη διαδικασία.

Επιπλέον, τα κεντρικά συστήματα εισάγουν ένα ενιαίο σημείο αστοχίας, πράγμα που σημαίνει ότι οποιαδήποτε παραβίαση, κακοδιαχείριση ή τεχνική δυσλειτουργία θα μπορούσε να θέσει σε κίνδυνο ολόκληρες τις εκλογές. Αυτές οι ευπάθειες υπογραμμίζουν την ανάγκη για εναλλακτικές προσεγγίσεις που μπορούν να διασφαλίσουν τόσο την ασφάλεια όσο και την ιδιωτικότητα, διατηρώντας παράλληλα τη διαφάνεια και την επαληθευσιμότητα. Μια λύση βασισμένη στο blockchain ,
ιδίως μια λύση που αξιοποιεί προηγμένες κρυπτογραφικές τεχνικές όπως οι αποδείξεις μηδενικής γνώσης ,
 προσφέρει μια πολλά υποσχόμενη οδό για την αντιμετώπιση αυτών των ζητημάτων. Καταργώντας την ανάγκη για μια κεντρική αρχή και επιτρέποντας κρυπτογραφικά επαληθεύσιμη αλλά ιδιωτική ψηφοφορία, ένα τέτοιο σύστημα μπορεί να προστατεύσει την ανωνυμία, να αποτρέψει την απάτη και να ενισχύσει την εμπιστοσύνη στις ψηφοφορίες των φοιτητών.

\newpage

% ------------------ Second Chapter Theoretical Background-------------------
\chapter{Θεωρητικό Υπόβαθρο}
Σε αυτή την ενότητα, παρουσιάζουμε το βασικό θεωρητικό υπόβαθρο που σχετίζεται με την παρούσα διατριβή. Ξεκινάμε με την εισαγωγή των βασικών εννοιών της τεχνολογίας blockchain, παρέχοντας τα θεμέλια για την κατανόηση των αποκεντρωμένων συστημάτων που αποτελούν τη βάση της προτεινόμενης εφαρμογής. Στη συνέχεια, εξετάζουμε τα βασικά εργαλεία από την επιστήμη της κρυπτογραφίας που χρησιμοποιούνται στην DApp, συμπεριλαμβανομένων των αποδείξεων μηδενικής γνώσης, των συναρτήσεων κατακερματισμού και των δέντρων Merkle, επισημαίνοντας τον ρόλο τους στην εξασφάλιση της ασφάλειας, της ακεραιότητας και της ιδιωτικότητας. Τέλος, εξετάζουμε λεπτομερώς το Midnight blockchain, εστιάζοντας στους μηχανισμούς του για τη διατήρηση της ιδιωτικότητας και της ανωνυμίας των χρηστών, οι οποίοι αποτελούν τη βάση για το ασφαλές και εμπιστευτικό σύστημα ψηφοφορίας που αναπτύχθηκε σε αυτή την εργασία.


\section{Τεχνολογία Blockchain}
Το blockchain είναι μία κατανεμημένη βάση δεδομένων που επιτρέπει την ασφαλή και ανθεκτική σε παραβιάσεις τήρηση δεδομένων χωρίς να υπάρχει η ανάγκη για μια κεντρική αρχή όπως για παράδειγμα η ύπαρξη ενός server. Ο έλεγχος των δεδομένων διαχέεται σε ένα δίκτυο από πολλαπλούς κόμβους (nodes). Κάθε κόμβος στο δίκτυο κρατάει ένα αντίγραφο όλων των δεδομένων και ακολουθεί ένα συμφωνημένο πρωτόκολλο για να ελέγχει την εγκυρότητα συναλλάγων και block. Αυτό που κάνει την τεχνολογία αυτή πολύ ισχυρή είναι ότι είναι πρακτικά αδύνατο να αλλοιώσει κάποιος τα δεδομένα , καθώς θα πρέπει να έχει στον έλεγχό του την πλειονότητα των κόμβων του δικτύου. Έτσι, τα δεδομένα παραμένουν πρακτικά αναλλοίωτα και οι χρήστες μπορούν να χρησιμοποιούν το δίκτυο δίχως την ανάγκη ύπαρξης μιας κεντρικής αρχής \cite{katanemhmena}.
\subsection{Μηχανισμοί consensus}
Ένα σημαντικό στοιχείο στα συστήματα blockchain είναι οι μηχανισμοί consensus, οι οποίοι αποτελούν τα πρωτόκολλα που ακολουθούν οι συμμετέχοντες κόμβοι προκειμένου να έρθουν σε συμφωνία για την τρέχουσα κατάσταση των δεδομένων στο δίκτυο. Διακρίνουμε τους δύο πιο γνωστούς τέτοιους μηχανισμούς:
\begin{itemize}
    \item \textbf{Proof Of Work(PoW)}: Το πρωτόκολλο αυτό χρησιμοποιείται από το Bitcoin και απαιτεί την ύπαρξη κόμβων που λέγονται miners οι οποίοι καλούνται να λύσουν κάποιο πολύπλοκο μαθηματικό πρόβλημα, το οποίο έγκυται στην αντιστροφή μιας συνάρτησης κατακερματισμού. Ο κόμβος που θα λύσει πρώτος το πρόβλημα λαμβάνει μια αμοιβή σε κρυπτονόμισα και είναι αυτός που θα προσθέσει το επόμενο μπλοκ στην αλυσίδα. Το PoW, παρότι είναι πολύ ασφαλές, απαιτεί κόμβους με πολύ υπολογιστική ισχύ και είναι δαπανηρό σε ενέργεια ενώ ταυτόχρονα καθιστά πρακτικά ακατόρθωτο σε κάποιον απλό χρήστη να συμμετέχει στο πρωτόκολλο \cite{midnightdocs}.
    \item \textbf{Proof Of Stake(PoS)}: Το PoS είναι πιο καινούργιο από το PoW και δεν βασίζεται στη λύση πολύπλοκων μαθηματικών προβλημάτων. Αντιθέτως, ο κόμβος που θα εκλεγεί ως αυτός που θα προσθέσει στην αλυσίδα το επόμενο μπλοκ βασίζεται σε έναν συνδυασμό τύχης αλλά και του ποσού του οποίου ο κόμβος έχει δεσμεύσει \cite{midnightdocs}. Χρησιμοποείται σε blockchains όπως το Ethereum και το Cardano και ενώ είναι πιο φιλικό προς το περιβάλλον, ταυτόχρονα δίνει την δυνατότητα στον απλό χρήστη να συμμετέχει στο πρωτόκολλο καθώς μπορεί ο ίδιος να δεσμεύσει ένα ποσό κρυπτονομισμάτων σε κάποιο ευρύτερο σύνολο οντοτήτων που ονομάζονται \textbf{stakepools}. Ένα \textbf{stakepool} αποτελεί ένα σύνολο κόμβων και χρηστών που αθροίζουν συνολικά που το ποσό που κάνουν stake έτσι ώστε να έχουν μεγαλύτερη πιθανότητα εκλογής. Αν το pool είναι τελικά ο νικητής του γύρου, τα κέρδη μοιράζονται ποσοστιαία σε όλους τους συμμετέχοντες \cite{cadranostakepools}.
\end{itemize}

\subsection{Smart Contracts}
Τα Smart Contracts είναι προγράμματα γραμμένα σε κάποια γλώσσα προγραμματισμού όπως η Plutus, η Solidity ή η Compact, τα οποία εκτελούνται στο blockchain όταν συγκεριμένες συνθήκες που έχουν ήδη προκαθοριστεί λαμβάνουν χώρα. Τα smart contracts περιλαμβάνουν κανόνες για το πως αλληλεπιδρούν οι συμμετέχοντες του δικτύου, ωστόσο στο Midnight όπως θα δούμε παρακάτω, παίζουν καθοριστικό ρόλο στην προστασία των δεδομένων των χρηστών \cite{midnightdocs}.

\subsection{Αποκεντρωμένες Εφαρμογές (dApps)}
Μία αποκεντρωμένη εφαρμογή είναι μια εφαρμογή η οποία δε βασίζεται σε κάποια κεντρική βάση δεδομένων και κάποιο κεντρικό server, αντιθέτως λειτουργεί πάνω σε ένα δίκτυο blockchain. Πολύ σημαντικό ρόλο σε αυτού του είδους τις εφαρμογές παίζουν τα smart contracts τα οποία και καθορίζουν το τι μπορεί να κάνει κάποιος χρήστη στην αποκεντρωμένη εφαρμογή \cite{midnightdocs}, ενώ συγκεκριμένα στο Midnight διασφαλίζουν και ότι οι προσωπικές πληροφορίες κάθε χρήστη παραμένουν ασφαλείς και δεν εκτίθενται ποτέ στο δίκτυο, αντί αυτού παραμένουν στον τοπικό του υπολογιστή.

\section{Εργαλεία από την επιστήμη της κρυπτογραφίας}
% ------------------ Hash Functions-------------------
\subsection{Συναρτήσεις Κατακερματισμού}
Οι συναρτήσεις κατακερματισμού είναι μαθηματικές συναρτήσεις που λαμβάνουν μια συμβολοσειρά εισόδου \(A\) και παράγουν μια συμβολοσειρά εξόδου σταθερού μεγέθους \(B = H(A)\). Το κύριο πλεονέκτημά τους έγκειται στη μονοκατευθυντική τους φύση: είναι υπολογιστικά αδύνατο να αντιστραφεί η συνάρτηση και να ανακτηθεί η αρχική είσοδος από την έξοδο. Με άλλα λόγια, δεδομένου του \(B\), είναι πρακτικά 
αδύνατο να προσδιοριστεί το \(A\) \cite{zachpagour}. Αυτή η ιδιότητα καθιστά τις συναρτήσεις κατακερματισμού ένα θεμελιώδες εργαλείο στην κρυπτογραφία για τη διασφάλιση της ακεραιότητας και της ασφάλειας των δεδομένων. Θα αναφέρουμε τις επιθμητές ιδιότητες που πρέπει να έχει μια συνάρτηση κατακερματισμού  \(H\):
\begin{itemize}
    \item \textbf{Αντίσταση Πρώτου Ορίσματος}: Είναι υπολογιστικά αδύνατο δεδομένης μιας τιμής \(y\)
    στο πεδίο τιμών της \(H\), να βρεθεί \(x\) τέτοιο ώστε \(Η(x) = y\). Δηλαδή είναι δύσκολη η αντιστοφή της συνάρτησης.
    \item \textbf{Αντίσταση Δεύτερου Ορίσματος}: Είναι υπολογιστικά δύκολο για κάποιο συγκεκριμένο στοιχείο  \(x\), ένα στοιχείο  \(x'\) διαφορετικό του \(x\), αλλά με \(H(x) = H(x')\).
    \item \textbf{Δυσκολία Εύρεσης Συγκρούσεων}: Είναι υπολογιστικά δύσκολο να βρεθούν δύο διαφορετικές τιμές \(x\), \(x'\) τέτοιες ώστε \(H(x) = H(x')\). \cite{zachpagour}
\end{itemize}
\newline
\newline
Αρκετές γνωστές συναρτήσεις κατακερματισμού χρησιμοποιούνται ευρέως στην πράξη, συμπεριλαμβανομένων των SHA-256, SHA-3 και του αλγορίθμου MD5 (αν και ο MD5 θεωρείται ανασφαλής για σύγχρονες εφαρμογές). Αυτές οι συναρτήσεις χρησιμοποιούνται σε ψηφιακές υπογραφές, συστήματα blockchain, κατακερματισμό κωδικών πρόσβασης και άλλες εφαρμογές κρίσιμης σημασίας για την ασφάλεια.
\newline
\newline
Μια θεμελιώδης εφαρμογή των συναρτήσεων κατακερματισμού είναι τα \textit{σχέδια δέσμευσης}. 
Ας υποθέσουμε ότι ένας χρήστης διαθέτει μια μυστική τιμή \(S\) που πρέπει να παραμείνει ιδιωτική. Ο χρήστης μπορεί να δεσμευτεί για αυτό το μυστικό υπολογίζοντας τον κατακερματισμό του, \(H(S)\). Η προκύπτουσα τιμή, \(H(S)\), μπορεί στη συνέχεια να δημοσιευτεί, για παράδειγμα, σε ένα blockchain, λειτουργώντας ως κρυπτογραφική δέσμευση για το \(S\) χωρίς να αποκαλύπτεται το ίδιο το μυστικό. Αργότερα, οποιοσδήποτε μπορεί να επαληθεύσει μια δηλωθείσα δέσμευση ελέγχοντας ότι ο παρεχόμενος κατακερματισμός ταιριάζει με την προηγουμένως δημοσιευμένη τιμή \(H(S)\), διασφαλίζοντας την ακεραιότητα της δέσμευσης και διατηρώντας το μυστικό \(S\) εντελώς κρυφό.
\newline

% ------------------ Zero Knowledge Proofs------------------
\subsection{Αποδείξεις Μηδενικής Γνώσης}
Η απόδειξη μηδενικής γνώσης είναι μια μέθοδος με την οποία ο αποδεικνύων(prover) μπορεί να πείσει τον επαληθευτή(verifier) ότι μια συγκεκριμένη δήλωση είναι αληθής, χωρίς να αποκαλύψει καμία πρόσθετη πληροφορία πέραν της αλήθειας της δήλωσης. Με άλλα λόγια, ο prover αποδεικνύει τη γνώση ενός μυστικού (ή της λύσης ενός προβλήματος) χωρίς να μοιράζεται το ίδιο το μυστικό.\cite{midnightdocs} Για παράδειγμα, μια ZKP θα μπορούσε να σας επιτρέψει να αποδείξετε ότι έχετε δικαίωμα ψήφου σε φοιτητικές εκλογές χωρίς να αποκαλύψετε την ταυτότητά σας ως φοιτητής. 

Αν και το μαθηματικό υπόβαθρο των αποδείξεων μηδενικής γνώσης ξεφεύγει από το σκοπό αυτής της εργασίας, αξίζει να περιγραφεί σε υψηλό επίπεδο ο τρόπος λειτουργίας τους:

\begin{itemize}
    \item Συμμετέχουν δύο μέρη: ο \textbf{prover}, που κατασκευάζει την απόδειξη θέλοντας να αποδείξει έναν ισχυρισμό ή μια πρόταση, και ο \textbf{verifier}, που ελέγχει την εγκυρότητά της. Ο prover κατέχει μια μυστική πληροφορία, τον \textit{witness}, και πρέπει να πείσει τον verifier για έναν ισχυρισμό χωρίς να αποκαλύψει τον witness \cite{midnightdocs}.
    \item Ο ισχυρισμός του prover (ο οποίος θα μπορούσε να είναι μια πρόταση της μορφής: <<ανήκω στο σύνολο των έγκυρων ψηφοφόρων>>) αναπαρίσταται μέσω ενός μαθηματικού κυκλώματος, γνωστού ως zero-knowledge circuit \cite{midnightdocs}.
    \item Στην αρχή πραγματοποιείται μια \textit{φάση αρχικοποίησης }, κατά την οποία δημιουργούνται τα αντίστοιχα \textit{proving} και \textit{verifying keys}. \cite{midnightdocs}
    \item Ο prover χρησιμοποιεί τον witness και το proving key για να κατασκευάσει την απόδειξη.
    \item Ο verifier, χρησιμοποιώντας το verifying key αλλά και το μαθηματικό κύκλωμα, ελέγχει αν η απόδειξη είναι έγκυρη. Αν επαληθευθεί, τότε ο ισχυρισμός του prover θεωρείται αληθής· διαφορετικά, είτε ο ισχυρισμός είναι λανθασμένος είτε ο prover δεν γνωρίζει στην πραγματικότητα έναν έγκυρο witness \cite{midnightdocs}.
\end{itemize}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\linewidth]{zkproofs.drawio.png}
  \caption{Ένα πρωτόκολλο μηδενικής γνώσης σε high level}
  \label{fig:diag}
\end{figure}


% ------------------ Merkle Trees------------------

\subsection{Δένδρα Merkle}

Τα δέντρα Merkle είναι μια κρυπτογραφική δομή δεδομένων που χρησιμοποιείται ευρέως σε συστήματα blockchain και άλλες εφαρμογές που απαιτούν επαλήθευση της ακεραιότητας των δεδομένων. Το βασικό τους πλεονέκτημα είναι ότι επιτρέπουν σε κάποιον να αποδείξει ότι μια συγκεκριμένη τιμή ανήκει σε ένα σύνολο χωρίς να αποκαλύψει την τιμή αυτή. Αυτή η ιδιότητα είναι απαραίτητη για την αποτελεσματική και διακριτική επαλήθευση.

Δομικά, ένα δέντρο Merkle είναι ένα δυαδικό δέντρο όπου κάθε \textbf{leaf node} περιέχει 
το hash ενός στοιχείου δεδομένων και κάθε \textbf{parrent node} περιέχει το hash της 
παράθεσης των κόμβων παιδιών του. Αυτή η ιεραρχία κατακερματισμού συνεχίζεται μέχρι τη 
ρίζα, που ονομάζεται \textbf{Merkle root}, η οποία αντιπροσωπεύει με μοναδικό τρόπο ολόκληρο το σύνολο των δεδομένων. Η επαλήθευση ότι μια τιμή ανήκει στο σύνολο απαιτεί μόνο έναν λογαριθμικό αριθμό υπολογισμών τιμών κατακερματισμού, καθιστώντας τα δέντρα Merkle εξαιρετικά αποδοτικά \cite{zachpagour}.


\begin{figure}[h!]
    \centering
    \begin{tikzpicture}[level distance=2.5cm,  % increase vertical spacing
      level 1/.style={sibling distance=6cm},   % increase horizontal spacing for first level
      level 2/.style={sibling distance=3cm}]   % increase horizontal spacing for second level
      \node {$\text{root}$}
        child {node {$H(H(A)\mid H(B))$}
          child {node {$H(A)$}}
          child {node {$H(B)$}}
        }
        child {node {$H(H(C)\mid H(D))$}
          child {node {$H(C)$}}
          child {node {$H(D)$}}
        };
    \end{tikzpicture}
    \caption{Δομή δέντρου Merkle: Κάθε lead node περιέχει το hash ενός στοιχείου δεδομένων και κάθε parrent node περιέχει το hash των παιδιών του. Ο root node αντιπροσωπεύει το hash ολόκληρου του συνόλου δεδομένων.}
    \label{fig:merkle_tree}
\end{figure}
Στο παρακάτω σχήμα, βλέπουμε ένα δέντρο Merkle με κόμβους φύλλων $H(A)$, $H(B)$, $H(C)$ και $H(D)$. 
Κάθε γονικός κόμβος περιέχει τον κατακερματισμό των παιδιών του, με αποκορύφωμα τη ρίζα Merkle, η οποία 
αντιπροσωπεύει τον κατακερματισμό ολόκληρου του συνόλου δεδομένων.  

Ας υποθέσουμε ότι τα $A$, $B$, $C$ και $D$ αντιπροσωπεύουν μυστικά κλειδιά διαφορετικών χρηστών και ο χρήστης $D$ 
θέλει να αποδείξει ότι ανήκουν στο δέντρο χωρίς να αποκαλύψει το μυστικό κλειδί $D$. Αυτό 
μπορεί να επιτευχθεί χρησιμοποιώντας μια απόδειξη μηδενικής γνώσης με βάση την ακόλουθη διαδικασία.  

Το πρωτόκολλο παρέχει στον χρήστη $D$ μόνο τους κατακερματισμούς που απαιτούνται για την ανακατασκευή της ρίζας, 
συγκεκριμένα $H(C)$ και $H(H(A) \mid H(B))$. Χρησιμοποιώντας αυτές τις τιμές μαζί με τον δικό του 
κατακερματισμό $H(D)$, ο χρήστης $D$ υπολογίζει τον κατακερματισμό της συνένωσης $(H(C) \mid H(D))$. 
Στη συνέχεια, συνδυάζει αυτόν τον νέο υπολογισμένο κατακερματισμό με τον κατακερματισμό που παρέχεται από το πρωτόκολλο 
$H(H(A) \mid H(B))$ για να ανακατασκευάσει τη ρίζα:  
\[
H\big(H(H(A)\mid H(B)) \mid (H(C)\mid H(D))\big)
\]  
Εάν ο προκύπτων κατακερματισμός ταιριάζει με τη ρίζα Merkle, η απόδειξη είναι έγκυρη και οποιοσδήποτε μπορεί 
να επαληθεύσει ότι ο χρήστης $D$ ανήκει στο δέντρο χωρίς να αποκαλύψει ποτέ το μυστικό $D$. Αυτή η 
διαδικασία δείχνει πώς τα δέντρα Merkle, σε συνδυασμό με τις αποδείξεις μηδενικής γνώσης, επιτρέπουν 
την αποτελεσματική επαλήθευση της ιδιότητας μέλους με διατήρηση της ιδιωτικότητας.

% ------------------ Midnight -------------------
\section{Midnight}

Σε αυτό το υπό-κεφάλαιο θα εξετάσουμε τα βασικά χαρακτηριστικά του Midnight, δίνοντας έμφαση στον τρόπο λειτουργίας των smart contracts, στον τρόπο με τον οποίο διασφαλίζεται η ανωνυμία των χρηστών των αποκεντρωμένων εφαρμογών που αναπτύσσονται σε αυτό το blockchain, καθώς και στις μοναδικές δυνατότητες που προσφέρει για ασφαλείς και αυτοματοποιημένες συναλλαγές χωρίς την ανάγκη κεντρικών διαμεσολαβητών.

\subsection{Lace Wallet}

Το  Midnight  χρησιμοποιεί το \textbf{Lace Wallet} ως κύριο μέσο διεπαφής των χρηστών με τις αποκεντρωμένες εφαρμογές, αλλά και ως μέσο διεξαγωγής συναλλαγών μεταξύ τους. Κάθε wallet διαθέτει μια μοναδική διεύθυνση, ορατή στον έξω κόσμο, καθώς και ένα ζεύγος κλειδιών — το \textbf{public key} και το \textbf{private key} — που αναπαριστώνται ως δεκαεξαδικές συμβολοσειρές. Το \textbf{public key} λειτουργεί ως αναφορά για το ποιος χρήστης εκτέλεσε ένα συγκεκριμένο transaction, ενώ το \textbf{private key}, που παραμένει μυστικό ακόμα και στον ίδιο τον χρήστη, χρησιμοποιείται για την υπογραφή των συναλλαγών που πραγματοποιεί το wallet. Το νόμισμα που χρησιμοποιεί το Midnight για τις συναλλαγές είναι το \textbf{tDUST} \cite{midnightdocs}.


\subsection{Proof Server}


Οποιοσδήποτε επιθυμεί να χρησιμοποιήσει μια αποκεντρωμένη εφαρμογή βασισμένη στο Midnight πρέπει να εγκαταστήσει και να τρέξει τοπικά στον υπολογιστή του τον proof server, ο οποίος είναι ενθυλακωμένος μέσα σε ένα docker container. Ο proof server παράγει τις αποδείξεις μηδενικής γνώσης για κάθε transaction ενός smart contract. Οι αποδείξεις αυτές αποτελούν το εχέγγυο ότι ο χρήστης μιας αποκεντρωμένης εφαρμογής, και κατά συνέπεια του αντίστοιχου smart contract, έχει ακολουθήσει όλους τους κανόνες που ορίζει κάθε transaction. Στη συνέχεια, η απόδειξη προωθείται στο δίκτυο ώστε να επαληθευθεί η ορθότητά της \cite{midnightdocs}.

Αξίζει να τονιστεί ότι ο proof server δεν συνδέεται ποτέ στο διαδίκτυο ούτε αποστέλλει δεδομένα σε τρίτους αποδέκτες. Λειτουργεί αποκλειστικά τοπικά για κάθε χρήστη και παράγει αποδείξεις μηδενικής γνώσης με πλήρη ασφάλεια.


\subsection{Smart Contracts στο Midnight }

Το Midnight χρησιμοποιεί την compact ως γλώσσα προγραμματισμού για ανάπτυξη smart contracts, η οποία έχεθ αναπτυχθεί από την ομάδα του Midnight. Θα κάνουμε μια σύντομη περιήγηση στα βασικά στοιχεία της compact μέσω ενός απλού smart contract. Εκτενέστερη ανάλυση θα πραγματοποιηθεί κατά την παρουσίαση του smart contract που αναπτύχθηκε για τη δική μας εφαρμογή.
Παρουσιάζουμε παρακάτω ένα απλό smart contract το οποίο ορίζει μια public μεταβλητή και επιτρέπει μόνο στον δημιουργό του contract να την αλλάξει \cite{midnightdocs}.

\begin{figure}[h]
\begin{lstlisting} % you can choose other language or leave it generic
import CompactStandardLibrary;

witness secretKey(): Bytes<32>;

export ledger organizer: Bytes<32>;
export ledger restrictedCounter: Counter;
constructor() {
  organizer = publicKey(secretKey());
}

export circuit increment(): [] {
  assert(organizer == publicKey(secretKey()), "not authorized");
  restrictedCounter.increment(1);
}

circuit publicKey(sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([pad(32, "some-domain-seperator"), sk]);
}
\end{lstlisting}

\caption{Ένα απλό smart contract γραμμένο σε compact}
\end{figure}

\subsubsection{Το ledger και η public state}
Όσες μεταβλητές έχουν μπροστά τη λέξει-κλειδί \textbf{ledger} αποτελούν την public state του smart contract και είναι ορατές σε όλο το blockchain. Στο παράδειγμά μας, η μεταβλητή organizer είναι public και αποτελεί την διεύθυνση του δημιουργού του contract μέσω μιας δεκαεξαδικής συμβολοσειράς. Επίσης η μεταβλητή resrictedCounter είναι δημόσια και είναι ένας απλός μετρητής.

\subsubsection{Ο witness και η private state}
Όσες μεταβλητές έχουν μπροστά τη λέξη κλειδί \textbf{witness} αποτελούν την private state του smart contract και ζουν αποκλειστικά στον υπολογιστή του χρήστη. Είναι σημαντικό να τονιστεί ότι η πραγματική τιμή τους δεν είναι ποτέ ορατή στο smart contract, απλά όσες μεταβλητές έχουν τη λέξη witness μπροστά αποτελούν μια διεπαφή στην private state του χρήστη \cite{midnightdocs}. Στο παράδειγμά μας η μεταβλητή secretKey αποτελεί το μυστικό κλειδί του χρήστη και η πραγματική της τιμή δεν αποκαλύπτεται ποτέ δημόσια, ούτε στο contract. Μόνο ο χρήστης γνωρίζει την τιμή της και είναι στη δική του δικαιοδοσία να ορίσει ποια θα είναι αυτή. Δηλαδή μπορεί διαφορετικοί χρήστες μιας αποκεντρωμένης εφαργμογής να ορίσουν ο καθένας τον δικό του witness, στη δική μας περίπτωση το δικό του secretKey.

\subsubsection{Τα circuits}
Τα circuits μπορούν να παρομοιαστούν περίπου σαν τις συναρτήσεις σε μια γλώσσα προγραμματισμού σαν την C. Μπορούν να επιστρέφουν ή όχι τιμές, ανάλογα με αυτό που ορίζει ο προγραμματιστής. Χωρίζονται σε δύο κατηγορίες: 
\begin{itemize}
    \item \textbf{pure circuits}: δεν αλλάζουν ούτε χρησιμοποιούν την private ή την public state (δηλαδή τις ledger μεταβλητές και τους witnesses),
    \item \textbf{impure circuits}: μπορούν να τροποποιούν και να χρησιμοποιούν την public και την private state. Τα impure circuits κατά κανόνα αποτελούν τις ενέργειες που μπορεί να κάνει ένας χρήστης στο smart contract, δηλαδή είναι τα entry points στο smart contract καθώς και τα transactions που μπορεί να εκτελέσει ένας χρήστης. Κάθε impure circuit μεταγλωττίζεται σε γλώσσα Typescript και μπορεί να χρησιμοποιηθεί σαν μια συνάρτηση Typescript \cite{midnightdocs}.
\end{itemize}
Στο παράδειγμά μας pure circuit είναι το publicKey το οποίο λειτουργεί απλά σαν hash function αξιοποιώντας την συνάρτηση persistentHash της βιβλιοθήκης. Αυτό το cirtcuit χρησιμοποιείται για να υπολογιστεί το hash του secretKey.

Το impure circuits είναι το increment το οποίο προσπαθεί να αυξήσει την τιμή της ledger μεταβλητής counter. Ωστόσο μέσα σε αυτο το circuit παρατηρούμε ότι χρησιμοποείται η έκφραση \textbf{assert}. Κάθε τέτοια έκφραση που είναι σε ένα circuit αποτελεί τους κανόνες που ορίζει το smart contract και διέπουν τη λειτουργία του \cite{midnightdocs}. Το συγκεκριμένο assert επιβάλλει ότι μόνο ο organizer του smart contract, δηλαδή αυτός που γνωρίζει ένα secretKey τέτοιο ώστε το hash αυτού του secretKey να ισούται με τη μεταβλητή organizer, έχει δικαίωμα να αυξήσει τον restrictedCounter. Διαφορετικά, αν ένας χρήστης που δεν γνωρίζει το έγκυρο secretKey προσπαθήσει να εκτελέσει ένα transaction με το increment circuit, αυτό θα αποτύχει και θα εμφανιστεί το μήνυμα λάθους "not authorized".

Σε αυτό το σημείο πρέπει να σημειώσουμε ότι μόλις ένα contract μεταγλωττιστεί, τότε για κάθε impure circuit που περιλαμβάνεται στο contract δημιουργούνται τα εξής αρχεία:
\begin{itemize}
    \item \textbf{.zkir αρχεία}: Αποτελούν την ενδιάμεση αναπαράσταση του circuit σε μηδενική γνώση και ουσιαστικά αναπαριστούν τους κανόνες που θέτει το συγκεκριμένο circuit. Για κάθε τέτοιο αρχείο, υπάρχει και η δυαδική το αναπαράσταση σε ένα .bzkir αρχείο
    \item \textbf{.prover αρχεία}: Είναι τα proving keys στο πλαίσιο ενός πρωτόκολλου αποδείξεων μηδενικής γνώσης.
    \item \textbf{.verifier αρχεία}: Είναι τα verifying keys στο πλαίσιο ενός πρωτόκολλου αποδείξεων μηδενικής γνώσης. \cite{midnightdocs}
\end{itemize}
Στο δικό μας απλό smart contract θα είχαμε τα αρχεία increment.zkir, increment.bzkir, increment.prover, increment.verifier.

Κατά την δημιουργία ενός transaction μέσω του increment circuit ο χρήστης, χρησιμοποιώντας .prover κλειδί και το .zkir αρχείο κατασκευάζει μέσω του proof server μια απόδειξη μηδενικής γνώσης. Αυτή η απόδειξη, μαζί με το .verifier κλειδί διαχέονται στο δίκτυο και αναλόγως με την ορθότητα της απόδειξης, το transction γίνεται αποδεκτό και πραγματοποιείται αλλαγή στην public state του contract ή απορρίπτεται.


\newpage
% ------------------ Third Chapter Methodology and Implementation-------------------
\chapter{Μεθοδολογία και Υλοποίηση}
Σε αυτή την ενότητα θα περιγράψουμε την μεθοδολογία που ακολουθήθηκε για το σχεδιασμό της αποκεντρωμένης εφαρμογής. Θα ξεκινήσουμε με μια γενική περιγραφή της εφαρμογής και παρουσιάζοντας τον τρόπο με τον οποίο τα επιμέρους κομμάτια που την αποτελούν επικοινωνούν και αλληλεπιδρούν μεταξύ τους. Στη συνέχεια θα γίνει εκτενής αναφορά στο smart contract που αναπτύχθηκε, αναλύοντας λεπτομερώς όλα τα στοιχεία του και εξηγώντας πως μέσω αυτού διασφαλίζονται τα επιθυμητά χαρακτηριστικά ενός ασφαλούς e-voting συστήματος, όπως είναι η ανωνυμία και η μοναδικότητα στην ψήφο. Επίσης, θα πραγματοποιηθεί γενική επισκόπηση του κώδικα που χρησιμοποιήθηκε και το πώς από την compact δημιουργείται κώδικας Typescript ο οποίος στη συνέχεια αξιοποιείτα για την ανάπτυξη της εφαρμογής.
Τέλος, θα παρουσιαστεί ο κώδικας του server του πανεπιστημίου, δηλαδή πως αυθεντικοποιούνται οι φοιτητές και πως δημιουργείται το smart contract.

\section{Γενική επισκόπηση της αποκεντρωμένης εφαρμογής}
\subsection{Stakeholders}
Η συγκεκριμένη εφαρμογή περιλαμβάνει τους εξής εμπλεκόμενους:
\begin{itemize}
    \item \textbf{Φοιτητές ως ψηφοφόρους}: Όλοι οι φοιτητές που είναι εγγεγραμμένοι στο πανεπιστήμιο έχουν δικαίωμα ψηφοφορίας σε όλες τις διαθέσιμες ψηφοφορίες της εφαρμογής.
    \item \textbf{Φοιτητές ως διοργανωτές}: Όλοι οι φοιτητές που είναι εγγεγραμμένοι στο πανεπιστήμιο έχουν δικαίωμα να δημιοργήσουν οι ίδιοι ψηφοφορίες καθορίζοντας τις ερωτήσεις και τις διαθέσιμες επιλογές.
    \item \textbf{Το πανεπιστήμιο}: Το πανεπιστήμιο λειτουργεί ως μια έμπιστη κεντρική αρχή και το μόνο που έχει δικαιοδοσία να κάνει ως εμπλεκόμενος είναι να δημιουργήσει το smart contract εξασφαλίζοντας ότι έγκυροι ψηφοφόροι θα είναι μόνο όλοι οι εγγεγραμένοι φοιτητές του πανεπιστημίου. Άπαξ και δημιουργηθεί και δημοσιευθεί στο δίκτυο το smart contract, το πανεπιστήμιο δεν μπορεί να συμμετέχει στην εφαρμογή, δηλαδή ούτε να ψηφίσει ούτε να δημιουργήσει ψηφοφορίες.
\end{itemize}


\subsection{Σχεδιασμός και συστατικά του συστήματος}
Το σύστημά μας αποτελείται από τα εξής συστατικά:
\begin{itemize}
    \item \textbf{Smart Contract}: Λειτουργεί ως μια μικρή βάση δεδομένων και αποθηκεύει on-chain σε δομές δεδομένων όλα τα χαρακτηριστικά των ψηφοφοριών, δηλαδή τις ερωτήσεις μιας ψηφοφορίας, τις διαθέσιμες επιλογές, τους επιτρεπτούς ψηφοφόρους, τα αποτελέσματα και τον κάθε οργανωτή μιας ψηφοφορίας. Ταυτόχρονα, όπως θα αναλυθεί παρακάτω, το contract περιλαμβάνει όλους τους κανόνες που πρέπει να διέπουν τη λειτουργία της εφαρμογής, εξασφαλίζοντας μεταξύ άλλων ότι μόνο εγγεγραμένοι φοιτητές μπορούν να ψηφίσουν, ότι οι ψήφοι παραμένουν ανώνυμοι και ότι κανείς δε μπορεί να διπλο-ψηφίσει. Τα παραπάνω πραγματοποιούνται με τη χρήση τεχνικών από την επιστήμη της κρυπτογραφίας και με την ενσωμάτωση αποδείξεων μηδενικής γνώσης.
    \item \textbf{University Server}: Περιλαμβάνει μια βάση δεδομένων με τα στοιχεία των φοιτητών (για απλούστευση μόνο όνομα χρήστη, κωδικό καθώς και το public key κάθε φοιτητή, δηλαδή το hash του secret key του) καθώς και έναν backend server ο οποίος χρησιμοποιείται για την επαλήθευση ότι ένας φοιτητής ανήκει στο πανεπιστήμιο. Επίσης, περιλαμβάνει την λειτουργία έναρξης της ψηφοφορίας καθώς το πανεπιστήμιο δημοσιεύει το smart contract στο δίκτυο του Midnight έχοντας εξασφαλίσει εκ των προτέρων ότι οι ικανοί ψηφοφόροι θα είναι μόνο οι εγγεγραμένοι στο πανεπιστήμιο. Σημειώνουμε εδώ ότι η βάση δεδομένων είναι βάση \textit{MongoDB} και ο κώδικας για το backend του πανεπιστημίου γράφτηκε σε \textit{NodeJS}
    \item \textbf{Frontend}: Το frontend αποτελεί τη διεπαφή χρηστών μέσω της οποίας οι φοιτητές μπορούν να χρησιμοποιήσουν την εφαρμογή αλληλεπιδρώντας με το smart contract. Πρακτικά, κάθε transaction του smart contract είναι και μια περίπτωση χρήσης η οποία πραγματοποιείται μέσω κώδικα \textit{Typescript} και \textit{ReactJS}.
    \item \textbf{Proof Server}: Όπως αναφέρθηκε και προηγουμένως, κάθε χρήστης της αποκεντρωμένης εφαρμογής πρέπει να τρέχει στον τοπικό του πολογιστή τον \textit{Midnight Proof Server} έτσι ώστε για κάθε transaction που επιθυμεί να πραγματοποιήσει, να δημιουργεί μια απόδειξη μηδενικής γνώσης η αποία αποστέλνεται για επαλήθευση στο δίκτυο. Σημειώνουμε ότι και το πανεπιστήμιο, κατά το transaction δημοσίευσης του contract, πρέπει να τρέχει τον δικό του Proof Server.
    \item \textbf{Midnight Network}: Η εφαμοργή λειτουργεί στο TestNet του Midnight, μέσω του οποίου πραγματοποιούνται όλα τα transactions και υπάρχει αποθηκεύμενη πολλαπλές φορές όλη η δημόσια πληροφορία που απαρτίζει την εφαρμογή.

\end{itemize}
Παρακάτω παρουσιάζουμε και το component diagram για μια γενική επισκόπηση του συστήματος:

\section{Ανάλυση του Smart Contract}
\subsection{ Οι μεταβλητές ledger}
Το smart contract αποτελείται από την δήλωση των μεταβλητών οι οποίες θα είναι δημόσιες στο δίκτυο: 
\begin{itemize}
    \item \textbf{university\_public\_key}: Είναι το δημόσιο κλειδί του πανεπιστημίου, συγκεκριμένα το hash του secret key του πανεπιστημίου.
    \item \textbf{votings}: Είναι ένα σύνολο με τα ids όλων των ψηφοφοριών. Κάθε ψηφοφορία όταν δημιουργείται διακρίνεται από ένα μοναδικό δεαεξαδικό id.
    \item \textbf{voting\_options}: Είναι ένα Map που περιέχει σαν κλειδί το id της ψηφοφορίας και σαν τιμή την διαθέσιμη επιλογή. Για τεχνικούς λόγους η διαθέσιμη επιλογή αναπαρίσταται και αυτή ως Map με κλειδί τον αριθμό της επιλογής και τιμή την ίδια την επιλογή.
    \item \textbf{voting\_questions}: Είναι ένα Map για τις ερωτήσεις με κλειδί το id της ψηφοφορίας και τιμή την ερώτηση ή γενικότερα το θέμα της ψηφοφορίας.
    \item \textbf{voting\_results}: Είναι ένα Map για το αποτέλεσμα κάθε ψηφοφορίας με κλειδί το id της και τιμή ένα δεύτερο Map. Το Map αυτό έχει κλειδί την επιλογή και ως τιμή έναν counter που αναπαριστά το πλήθος των φορών που επιλέχθηκε η συγκεκριμένη επιλογή.
    \item \textbf{eligible\_voters}: Οι συμμετέχοντες στις ψηφοφορίες αναπαρίστανται ως ένα Merkle Tree που περιέχει τα δημόσια κλειδιά τους, δηλαδή τα hash των μυστικών κλειδιών τους. Η χρήση Merkle Tree όπως θα περιγραφεί στη συνέχεια είναι καθοριστική για τη διατήρηση της ανωνυμίας.
    \item \textbf{voting\_states}: Είναι ένα Map με κλειδί το id της ψηφοφορίας και τιμή τύπου VOTE\_STATE που δηλώνει αν η ψηφοφορία είναι ανοικτή ή αν έχει κλείσει.
    \item \textbf{voting\_nulifiers}: Είναι ένα σύνολο από μοναδικές δεκαεξαδικές τιμές που δρουν σαν tokens προς κάθε ψηφοφόρο προς αποφυγή διπλο-ψηφίσματος.
    \item \textbf{publish\_voting\_nulifiers}: Είναι ένα σύνολο από μοναδικές δεκαεξαδικές τιμές που δρουν σαν tokens προς κάθε ψηφοφόρο ώστε να μην μπορεί ο κάθε ψηφοφόρος να δημοσιεύεσει 2 φορές την ψήφο του. Θα μιλήσουμε εκτενέστερα στη συνέχεια για τη δημοσίευση ψήφου.
    \item \textbf{hashed\_votes}: Είναι ένα σύνολο που περιέχει όλες τις ψήφους, αλλά κατακερματισμένες από hash function.
    \item \textbf{voting\_organizers}: Είναι ένα Map όπου κλειδί είναι το id της ψηφοφορίας και τιμή το δημόσιο κλειδί (δηλαδή το hash του ιδιωτικού κλειδιού) του διοργανωτή της συγκεκριμένης ψηφοφορίας.
    
\end{itemize}


\begin{figure}[h]
\begin{lstlisting} % you can choose other language or leave it generic
export ledger votings: Set<Bytes<32>>;               
export ledger voting_options: Map<Bytes<32>, Set<Bytes<32>>>; 
export ledger voting_questions: Map<Bytes<32>, Opaque<"string">>;
export ledger voting_results: Map<Bytes<32>, Map<Bytes<32>, Counter>>;        
export ledger eligible_voters: HistoricMerkleTree<5, Bytes<32>>;      
export ledger voting_states: Map<Bytes<32>, VOTE_STATE>;                
export ledger voting_nulifiers: Set<Bytes<32>>;         
export ledger publish_voting_nulifiers: Set<Bytes<32>>;         
export ledger voting_organizers: Map<Bytes<32>, Bytes<32>>;       
export ledger hashed_votes: Set<Bytes<32>>;      
\end{lstlisting}

\caption{Οι ledger μεταβλητές του smart contract}
\end{figure}



\subsection{ Ο κατασκευαστής}
Το smart contract έχει έναν κατασκευαστή ο οποίος αρχικοποιεί τις ledger μεταβλητές στις default τιμές και θέτει το university\_public\_key να είναι ίσο με το hash του secret key του τρέχοντος χρήστη ο οποίος θα είναι το πανεπιστήμιο. Έτσι, αρχικοποιείται το public key του πανεπιστημίου. Τέλος, ο κατασκευαστής λαμβάνοντας ως είσοδο ένα Vector με τα public keys των έγκυρων ψηφοφόρων, πραγματοποιεί την είσοδο αυτών στο Merkle Tree των έγκυρων ψηφοφόρων.


\begin{figure}[h]
\begin{lstlisting} 
constructor(eligible_voter_public_keys: Vector<5, Bytes<32>>) {
    university_public_key = disclose(public_key(local_secret_key()));
    votings.resetToDefault();
    voting_options.resetToDefault(); 
    voting_results.resetToDefault();
    voting_states.resetToDefault();
    voting_nulifiers.resetToDefault();
    voting_organizers.resetToDefault();
    voting_questions.resetToDefault();
    hashed_votes.resetToDefault();
    publish_voting_nulifiers.resetToDefault();
    count.increment(1);

    for (const v of disclose(eligible_voter_public_keys)) {
        eligible_voters.insert(v);
    }
}
\end{lstlisting}

\caption{Ο κατασκευαστής του smart contract}
\end{figure}



\subsection{Οι witness μεταβλητές και η private state}
Όπως έχουμε αναφέρει οι witness μεταβλητές αποτελούν την ιδιωτική κατάσταση κάθε χρήστη και γι αυτό το λόγο υλοποιούνται από τους διαφορετικούς χρήστες της εφαρμογής. Το αποτέλεσμα που θα δώσουν δε θα πρέπει να θεωρείται εμπιστεύστιμο. Στη δική μας υλοποίηση, για την ιδιωτική κατάσταση χρειαζόμαστε ένα αντικείμενο τύπου \textit{VoteGuardianPrivateState} και μια συνάρτηση που θα κατασκευάζει την ιδιωτική κατάσταση, δηλαδή αντικείμενα του παραπάνω τύπου, την createVoteGuardianPrivateState. 

\begin{figure}[h]
\begin{lstlisting} 
export type VoteGuardianPrivateState = {
  readonly secretKey: Uint8Array;
  voterPublicKeyPath: MerkleTreePath<Uint8Array>;
  votesPerVotingMap: Map<String, String>;
};

export const createVoteGuardianPrivateState = (
  secretKey: Uint8Array,
  voterPublicKeyPath: MerkleTreePath<Uint8Array>,
  votesPerVotingMap: Map<String, String>,
) => ({
  secretKey,
  voterPublicKeyPath,
  votesPerVotingMap,
});
\end{lstlisting}

\caption{Η private state του smart contract}
\end{figure}


Όπως έχουμε αναφέρει οι μεταβλητές witness ζουν αποκλειστικά τοπικά για κάθε χρήστη και δε δημοσιεύονται ποτέ στο δίκτυο ενώ ταυτόχρονα αποτελούν την μυστική πληροφορία που κατέχει ο prover σε ένα πρωτόκολλο μηδενικής γνώσης η οποία είναι σημαντική για την ορθότητα της απόδειξης. Στην εφαρμογή μας διακρίνονται τρεις τέτοιες μεταβλητές:
\begin{itemize}
    \item \textbf{local\_secret\_key}: Αποτελεί το secret key κάθε συμμετέχοντος ως μια δεκαεξαδική συμβολοσειρά. Δεν παίρνει κάποιο όρισμα, απλά επιστρέφει την ίδια private state και το ίδιο secret key, καθώς δεν αλλάζει την ιδιωτική κατάσταση.  \newline
    \textbf{Τι θα γινόταν αν ένας κακόβουλος χρήστης έκανε τη δική του υλοποίηση?} Πρακτικά αν ένας χρήστης όριζε για παράδειγμα η {local\_secret\_key} να επιστρέφει κάθε φορά ένα τυχαίο δεκαεξαδικό, τότε θα ήταν σχεδόν απίθανο να μαντέχει ένα secret key που να ανήκει σε αυτά των έγκυρων χρηστών οπότε δε θα μπορούσε να συμμετέχει στις ψηφορορίες. Για να υπήρχε πρόβλημα ασφάλειας, θα έπρεπε το secret key που θα επέστρεφε να ήταν ένα εκ των έγκυρων, κάτι το οποίο είναι υπολογιστικά αδύνατο.
    \item \textbf{find\_voter\_public\_key}: Παίρνει ως όρισμα το δημόσιο κλειδί ενός χρήστη και η τιμή επιστροφής του είναι τύπου \textit{MerkleTreePath} το οποίο περιέχει μια λίστα με όλα τα hashes που χρειάζεται να έχει ο κάτοχος του τρέχοντος φύλλου στο δέντρο (δηλαδή του τρέχοντος δημόσιου κλειδιού) ώστε να ανακατασκευάσει τη ρίζα. Ουσιαστικά αυτός ο witness αποτελεί τη γνώση που κατέχει ο έγκυρος ψηφοφόρος ότι γνωρίζει ένα έγκυρο μονοπάτι μέσα στο Merkle tree. Όπως θα δούμε στη συνέχεια, η απόδειξη πως ένας χρήστης είναι έγκυρος βασίζεται στην κλήση της συνάρτησης από τη βιβλιοθήκη της compact \textit{checkRoot} πάνω στο δένδρο των ψηφοφόρων με όρισμα το αποτέλεσμα που θα επιστρέψει ο witness. 
    \newline
    Στην υλοποίηση της εφαρμογής, η find\_voter\_public\_key χρησιμοποεί την \textit{findPathForLeaf} για το public key που λαμβάνει ως είσοδο και επιστρέφει το \textit{MerkleTreePath} για αυτό το public key. Αν το public key που δεχθεί ως όρισμα δεν υπάρχει στο δέντρο τότε επιστρέφει \textit{undefined}.
    \textbf{Τι θα γινόταν αν ένας κακόβουλος χρήστης έκανε τη δική του υλοποίηση?}. Ας υποθέσουμε ότι ένας μη έγκυρος χρήστης έχοντας πρόσβαση στο δημόσιο merkle tree υλοποιεί την find\_voter\_public\_key έτσι ώστε να επιστρέφει μια έγκυρη λίστα από hashes που κατ' επέκταση ανακατασκευάζουν επιτυχώς τη ρίζα. Θα μπορούσε να ξεγελάσει την εφαρμογή μας? Η απάντηση είναι όχι, καθώς 

    \item \textbf{secret\_vote}: Αποτελεί την μυστική ψήφο ενός ψηφοφόρου για ψηφοφορία με συγκεκριμένο id. Παίρνει ως όρισμα το id της ψηφοφορίας και επιστρέφει την ψήφο για τη συγκεκριμένη ψηφοφορία ψάχνοντας στο Map votesPerVotingMap το οποίο είναι αποθηκευμένο στην private state του ψηφοφόρου. Αν δεν υπάρχει ψήφος για ση συγκεκριμένη ψηφοφορία τότε θα επιστρέψει default τιμή, δηλαδή ένα Uint8Array με 32 μηδενικά. Η ουσία εδώ είναι η ψήφος να παραμένει μυστική για κάθε χρήστη και να δημοσιεύεται το hash αυτής. Στο τέλος της ψηφοφορίας ο χρήστης θα δημοσιεύει την ψήφο του, μη ακοπαλύπτοντας φυσικά ποια είναι αυτή, αλλά δημοσιεύοντας το hash της πραγματικής του ψήφου. Στη συνέχεια θα γίνεται έλεγχος αν αυτό το hash είναι ίδιο με το hash που υπάρχει αποθηκευμένο στο ledger. Αν ισχύει αυτό, σημαίνει ότι η ψήφος είναι σωστή.
\end{itemize}




Επίσης παρουσιάζουμε την υλοποίηση των witness function ως συναρτήσεις \textit{Typescript} στο σχήμα 3.3. 

\begin{figure}[h]
\centering
\begin{lstlisting}[language=TypeScript] 
local_secret_key: ({
    privateState,
    ledger,
  }: WitnessContext<Ledger, VoteGuardianPrivateState>): [VoteGuardianPrivateState, Uint8Array] => [
    privateState,
    privateState.secretKey,
  ],

  find_voter_public_key: (
    { privateState, ledger }: WitnessContext<Ledger, VoteGuardianPrivateState>,
    item: Uint8Array,
  ): [VoteGuardianPrivateState, MerkleTreePath<Uint8Array>] => [
    createVoteGuardianPrivateState(privateState.secretKey, ledger.eligible_voters.findPathForLeaf(item)!),
    ledger.eligible_voters.findPathForLeaf(item)!,
  ],   

  secret_vote: (
    { privateState, ledger }: WitnessContext<Ledger, VoteGuardianPrivateState>,
    votingId: Uint8Array,
  ): [VoteGuardianPrivateState, Uint8Array] => [
    privateState,
    toBytes32FromString(privateState.votesPerVotingMap.get(toHex(votingId))?.toString()),
  ],
\end{lstlisting}

\caption{Οι συναρτήσεις witness}
\end{figure}




\subsection{Τα pure circuits}
Το smart contract περιλαμβάνει τα ακόλουθα pure circuits:
\begin{itemize}
    \item \textbf{public\_key}: Υπολογίζει το hash του secret key επιστρέφοντας μια δεκαεξαδική τιμή.
    \item \textbf{nullifier}: Παίρνει ως είσοδο το secret key του χρήστη και το id της τρέχουσας ψηφοφορίας και με αυτό τον τρόπο δημιουργεί ένα μοναδικό hash για τον χρήστη για τη συγκεκριμένη ψηφοφορία.
    \item \textbf{generate\_voting\_id}: Χρησιμοποιείται για την απόδοση ενός μοναδικού id για μια ψηφοφορία. Παίρνει ως είσοδο το secret key του οργανωτή της ψηφοφορίας καθώς και την δημόσια μεταβλητή count η οποία αυξάνεται κατά 1 κατά τη δημιουργία κάθε ψηφοφορίας. Έτσι επιτυγχάνεται η μοναδικότητα στα ids κάθε ψηφοφορίας. 
    \item \textbf{prove\_eligibility}: Αυτό το circuit χρησιμοποείται για να ελέγχξει αν ο τρέχων χρήστης είναι έγκυρος επιστρέφοντας true ή false αντίστοιχα. Υπολογίζεται η μεταβλητή path που είναι το αποτέλεσμα της επιστροφής της find\_voter\_public\_key για το public key του τρέχοντος χρήστη και πρέπει να αποτελεί ένα έγκυρο μονοπάτι μέσα στο δέντρο. Στη συνέχεια, με χρήση της συνάρτηρης \texit{checkRoot} ελέγχεται το συγκεκριμένο path μπορεί να ανακατασκευαστεί η ρίζα. Αν ναι σημαίνει πως το path είναι έγκυρο και επιστρέφεται true, διαφορετικά false.
    \item \textbf{publish\_nullifier}: Παίρνει ως είσοδο το secret key του χρήστη και το id της τρέχουσας ψηφοφορίας και με αυτό τον τρόπο δημιουργεί ένα μοναδικό hash για τον χρήστη για τη συγκεκριμένη ψηφοφορία.
    \item \textbf{hash\_secret\_vote}: Παίρνει ως είσοδο την ψήφο, το id της ψηφοφορίας και το secret key του ψηφοφόρου και δημιουργεί ένα μοναδικό hash για την ψήφο, ανά ψηφοφορία και ανά χρήστη.
    
\end{itemize}


\begin{figure}[H]
\centering
\begin{lstlisting}[language=TypeScript] 
circuit public_key(sk: Bytes<32>): Bytes<32> {
    return persistentHash<Bytes<32>>(sk);
}

circuit nullifier (sk: Bytes<32>, voting_id: Bytes<32>): Bytes<32> {
   return persistentHash<Vector<3, Bytes<32>>>(
           [pad(32, "nulifier-domain"), voting_id as Bytes<32>, sk]);
}

circuit publish_nullifier (sk: Bytes<32>, voting_id: Bytes<32>): Bytes<32> {
   return persistentHash<Vector<3, Bytes<32>>>(
           [pad(32, "publish-nulifier-domain"), voting_id as Bytes<32>, sk]);
}

circuit generate_voting_id (count: Field, sk: Bytes<32>) : Bytes<32> {
    return persistentHash<Vector<3, Bytes<32>>>(
           [pad(32, "generate_id"), count as Bytes<32>, sk]);
}

circuit hash_secret_vote(
    secret_vote: Bytes<32>, 
    voting_id: Bytes<32>, 
    secret_key: Bytes<32>
): Bytes<32> {
    return persistentHash<Vector<4, Bytes<32>>>(
        [pad(32, "secret-vote-domain"), voting_id, secret_vote, secret_key]
    );
}

circuit prove_eligibility(): Boolean {
    const participant_public_key = public_key(local_secret_key());
    const path = find_voter_public_key(participant_public_key);

    return eligible_voters.checkRoot(disclose(merkleTreePathRoot<5, Bytes<32>>(path)));
        
}
\end{lstlisting}

\caption{Τα pure circuits του smart contract}
\end{figure}




\newpage

\subsection{Τα impure circuits}
Κάθε impure circuit που περιλαμβάνεται στο smart contract μπορεί να χρησιμοποιεί τις witness functions και να μεταβάλλει τις ledger μεταβλητές, αλλάζοντας την δημόσια κατάσταση του smart contract. Κάθε τέτοιο circuit μετά την μεταγλώττιση από Compact σε Typescript είναι διαθέσιμο να κληθεί και αποτελεί ένα transaction στο Midnight. Πριν ξεκινήσουμε την ανάλυση των circuits, θα εξηγήσουμε μια κοινή λογική που υπάρχει σε όλα τα circuits και κατά την ανάλυση θα αναφέρουμε ποια από τα παρακάτω ισχύουν σε κάθε circuit. Συγκεκριμένα:
\begin{enumerate}
    \item Το πανεπιστήμιο δεν μπορεί να κάνει κανένα transaction, η "δουλειά" του τελειώνει μετά την δημοσίευση του contract. Γι' αυτό το λόγο, στην αρχή κάθε circuit ελέγχεται με τη δήλωση \textit{assert} ότι το public key του πανεπιστημίου (το οποίο υπάρχει ως ledger μεταβλητή) πρέπει να διαφέρει από το public key του τρέχοντας χρήστη.
    \item Κάθε άλλο transaction πρέπει να πραγματοποιείται μόνο από έγκυρους χρήστες, δηλαδή από τους φοιτητές. Γι' αυτό το λόγο στην αρχή των circuits που απαιτούν αυθεντικοποίηση πραγματοποιείται έλεγος με δήλωση \textit{assert} ότι ο χρήστης ανήκει στο merkle tree, μέσω του 
    textit{prove\_eligibility} circuit.
    \item Κάθε transaction που πραγματοποιείται από τον διοργανωτή της ψηφοφορίας απαιτεί έλεγχο ότι ο συγκεκριμένος χρήστης είναι ο διοργανωής, μέσω  \textit{assert} το συγκεκριμένο id της ψηφοφορίας "ανήκει" στο τρέχον public key, δηλαδή στο hash του τρέχοντος secret key. Με άλλα λόγια ότι το Map voting\_organizers περιέχει το ζεύγος voting\_id, organizer\_public\_key.
\end{enumerate}

Για όλους τους παραπάνω κανόνες, σε περίπτωση που δεν ισχύει κάποιος από αυτούς κατά την πραγματοποίηση ενός transaction μέσω ων circuits, τότε το transaction δεν ολοκληρώνεται και εμφανίζεται αντίστοιχο μήνυμα λάθους στον μη έγκυρο χρήστη που το εκτέλεσε.
Συγκεκριμένα, το smart contract περιλαμβάνει τα ακόλουθα impuure circuits:

\begin{itemize}
    \item \textbf{create\_voting}: Με αυτό το transaction δημιουργείται μια νέα ψηφοφορία. Ισχύουν τα (1) και (2) από παραπάνω. Η ψηφοφορία αποκτά ένα μοναδικό id και γίνεται είσοδος αυτού του id στη μεταβλητή votings, και σαν διοργανωτής ορίζεται το τρέχων public key. Αυτό πραγματοποιείται με είσοδο στη μεταβλητή voting\_organizers. Η ψηφοφορία αρχικοποιείται ως OPEN και οι υπόλοιπες ledger μεταβλητές αρχικοποιούνται με default τιμές έχοντας ως κλειδί σε κάθε Map το id.
    \item \textbf{edit\_question}: Με αυτό το transaction καθορίζεται η ερώτηση της συγκεκριμένης ωηφοφορίας. Ισχύουν τα (1), (2) και (3) από παραπάνω. Το circuit δέχεται ορίσματα το id της ψηφοφορίας και την ερώτηση και εισάγει στη ledger μεταβλητή voting\_questions το ζεύγος αυτό.
    \item \textbf{add\_option}: Με αυτό το transaction εισάγεται μια επιλογή για την ψηφοφορία. Ισχύουν τα (1), (2) και (3) από παραπάνω. Το circuit δέχεται ως όρισμα το id της ψηφοφορίας και την επιλογή. Γίνεται εισαγωγή στη ledger μεταβλητή voting\_options το id της ψηφοφορίας σαν κλειδί και προστίθεται στο σύνολο η επιλογή Επίσης, αρχικοποιείται με τον default μετρητή και η ledger μεταβλητή voting\_results για τη συγκεκριμένη επιλογή.
    \item \textbf{open\_voting}: Με αυτό το transaction ανοίγει η συγκεκριμένη ψηφοφορία, δηλαδή τίθεται η κατάστασή της ως OPEN. Ισχύουν τα (1), (2) και (3) από παραπάνω. Το transaction δέχεται ως όρισμα το id της ψηφοφορίας και ελέγχει μέσω \textit{assert} ότι η ψηφοφορία είναι κλειστή, διαφορετικά εμφανίζει μήνυμα λάθους. Στη συνέχεια, γίνεται εισαγωγή στη ledger μεταβλητή
    voting\_states το ζεύγος του id της ψηφοφορίας με την τιμή OPEN.
    \item \textbf{close\_voting}: Συμμετρικό του open\_voting.
    \item \textbf{cast\_vote}: Με αυτό το transaction ένας έγκυρος χρήστης μπορεί να ψηφίσει. 
    \begin{enumerate}
        \item Αρχικά ελέγχεται ότι η ψηφοφορία είναι ανοικτή μέσω σχετικής δήλωσης \textit{assert}. Αν δεν είναι ανοικτή, εμφανίζεται σχετικό μήνυμα λάθους και το transaction εγκαταλείπεται.
        \item Πραγματοποιούνται οι έλεγχοι (1), (2) από παραπάνω και αν κάποιος αποτύχει δηλαδή αν ο χρήστης είναι το πανεπιστήμιο, ή αν ο χρήστης δεν είναι έγκυρος τότε το transaction εγκαταλείπεται με σχετικό μήνυμα λάθους. Σημειώνεται εδώ ότι όλοι οι έγκυροι χρήστες μπορούν να ψηφίσουν σε όλες τις ψηφοφορίες.
        \item Στη συνέχεια γίνεται ο έλεγχος για double-voting δηλαδή έλεγχος για το αν ο τρέχων χρήστης έχει ήδη ψηφίσει για αυτή την ψηφοφορία. Για να δούμε πως γίνεται αυτό υποθέτουμε ότι έχουμε φτάσει στο τέλος των ελέγχων όπου ο χρήστης έχει καταχωρίσει την ψήφο του. Μόλις γίνει αυτό, υπολογίζεται το \textit{voting\_nullifier} το οποίο είναι hash του secret key με διαφορετικό domain για να ξεχωρίζει από το public key. Το hash αυτό πραγματοποιείται μέσω του pure circuit nullifier και δέχεται επίσης ως όρισμα μαζί με το secret key και το \textit{voting\_id} ώστε να είναι μοναδικό ανά χρήστη ανά ψηφοφορία. Το \textit{voting\_nullifier} καταχωρείται στο ledger σύνολο \textit{voting\_nulifiers}. Όταν λοιπόν το circuit φτάσει στον έλεγχο για double-voting ελέγχεται αν το hash με τη nullifier του secret key του τρέχοντος χρήστη για τη συγκεκριμένη ψηφοφορία υπάρχει στο σύνολο των \textit{voting\_nulifiers}. Αν ναι σημαίνει πως ο χρήστης έχει ήδη ψηφίσει οπότε εμφανίζεται μήνυμα λάθους και εγκαταλείπεται το transaction, διαφορετικά συνεχίζονται οι ενέργειες.
        \item Στη συνέχεια, ο typescript κώδικας της dapp φροντίζει ώστε να ενημερωθεί η private state του χρήστη με τη συγκεκριμένη ψήφο, έτσι ώστε η κλήση της witness μεταβλητής \textit{secret\_vote(voting\_id)} να επιστρέψει την ψήφο του ψηφοφόρου για τη συγκεκριμένη ψηφοφορία. Υπενθυμίζουμε ότι παρότι ο κώδικας της dapp θα ενημερώσει την private state με την επιλεγμένη ψήφο, στην πραγματικότητα ο χρήστης μπορεί να τροποποιήσει τον κώδικα και να αναθέσει στην επιλεγμένη ψήφο του όποια τιμή θέλει. Ο έλεγχος για το αν η ψήφος είναι έγκυρη, θα πραγματοποιηθεί σε επόμενο transaction.
        \item Έχοντας οριστεί και το private state, το επόμενο βήμα του transaction είναι να υπολογιστεί το hash της επιλεγμένης ψήφου, καλώντας το circuit \textit{hash\_secret\_vote}. Η κλήση σε αυτό το circuit επιστρέφει ένα hash για την ψήφο αλλά δεν αποκαλύπτει την πραγματική τιμή της ψήφου, δηλαδή τη witness μεταβλητή \textit{secret\_vote(voting\_id)}.
        \item Τελευταίο βήμα είναι η εισαγωγή του hash που υπολογίστηκε πριν στη ledger μεταβλητή \textit{hashed\_votes}.
        \item Τέλος, γίνεται καταχώρηση της ψήφου στη ledger μεταβλητή \textit{voting\_results} όπου για το συγκεκριμένο \textit{voting\_id} αναζητάται το συγκεκριμένο \textit{vote\_option} και αυξάνεται ο μετρητής που του αντιστοιχεί κατά 1.
        
        
    \end{enumerate}
    \item \textbf{publish\_vote}:
    \begin{enumerate}
        \item Αρχικά ελέγχεται ότι η ψηφοφορία είναι ανοικτή μέσω σχετικής δήλωσης \textit{assert}. Αν δεν είναι ανοικτή, εμφανίζεται σχετικό μήνυμα λάθους και το transaction εγκαταλείπεται.
        \item Πραγματοποιούνται οι έλεγχοι (1), (2) από παραπάνω και αν κάποιος αποτύχει δηλαδή αν ο χρήστης είναι το πανεπιστήμιο, ή αν ο χρήστης δεν είναι έγκυρος τότε το transaction εγκαταλείπεται με σχετικό μήνυμα λάθους. 
        \item Ελέγχεται ότι ο χρήστης δεν έχει εκτελέσει δεύτερη φορά το ίδιο transaction , ακολουθώντας ίδια λογική με το cast\_vote transaction χρησιμοποιώντας nulifiers.
        \item Υπολογίζεται το hash της ψήφου, καλώντας το circuit hash\_secret\_vote με ορίσματα την ψήφο του χρήστη η οποία εξάγεται από τη witness μεταβλητή secret\_vote, το id της ψηφοφορίας και το secret key. Μετά ελέγχεται αν αυτό το hash υπάρχει στο σύνολο hashed\_votes στο ledger. Η ουσία εδώ είναι πως, αν τα δύο hashes δεν ταυτίζονται, σημαίνει πως μετά την εκτέλεση του cast\_vote ο χρήστης άλλαξε το private state του και δηλαδή την ψήφο του, γιατί όπως έχουμε εξηγήσει, την private state μπορεί να την αλλάζει ο κάθε χρήστης όπως θέλει. Τότε απορρίπτεται το transaction και εμφανίζεται κατάλληλο μήνυμα λάθους. Αν από την άλλη ταυτίζονται τα 2 hashes, τότε η ψήφος δεν άλλαξε και συνεχίζονται οι έλεγχοι.
        \item Τέλος, ελέγχεται αν η ψήφος είναι έγκυρη, δηλαδή αν το secret\_vote για τη συγκεκριμένη ψηφοφορία ανήκει στο map voting\_options του συγκεκριμένου id ψηφοφορίας.\item Τέλος, γίνεται καταχώρηση της ψήφου στη ledger μεταβλητή \textit{voting\_results} όπου για το συγκεκριμένο \textit{voting\_id} αναζητάται το συγκεκριμένο \textit{vote\_option} και αυξάνεται ο μετρητής που του αντιστοιχεί κατά 1.
       \end{enumerate} 
\end{itemize}
        Σε αυτό το σημείο, αξίζει να σημειωθεί πως οι ψήφοι σαν οντότητες δεν κρυπτογραφούνται, αλλά εισάγονται στο ledger σύνολο \textit{voting\_results}. Ωστόσο, υπάρχει πλήρης ανωνυμία καθώς η χρήση Merkle Tree εγγυάται ότι όταν ο τρέχων χρήστης αποδεικνύει εγκυρότητα βρίσκοντας ένα έγκυρο μονοπάτι μέσα στο δέντρο, δεν αποκαλύπτεται καμία πληροφορία για το public key του, και προφανώς για το secet key που χρησιμοποιήθηκε.

        Επίσης, με τη χρήση του μοτίβου cast\_vote - publish\_vote, δηλαδή ψήφος και δημοσίευση της, λύνουμε ένα θέμα που θα υπήρχε αν χρησιμοποιούσαμε μόνο το cast\_vote, το οποίο έγκειται στην εμφάνιση των αποτελεσμάτων της ψηφοφορίας. Αν υπήρχε μόνο cast\_vote τότε, με το που ψηφίζει ένας χρήστης, καταχωρείται η ψήφους του στο voting\_results, και στο interface της εφαρμογής , μπορεί οποιοσδήποτε να δει τα αποτελέσματα ενώ η ψηφοφορία είναι ακόμα ανοιχτή. Με αυτό τον τρόπο, θα μπορούσε να επηρεαστεί κάποιος ψηφοφόρος βλέποντας την πορεία της ψηφοφορίας και είτε να μην ψηφίσει καθόλου, είτε να αλλάξει γνώμη. Με το μοτίβο publish\_vote όμως, ο χρήστης όταν ψηφίζει κρατάει μυστική την ψήφο του και απλά δημοσιεύει μια δέσμευση σε αυτή, δηλαδή ένα hash. Η μεταβλητή voting\_results δεν αλλάζει, συνεπώς δεν αλλάζει το αποτέλεσμα της ψηφοφορίας. Όταν η ψηφοφορία κλείσει, τότε οι χρήστες δημοσιεύουν την ψήφο τους (χωρίς να είναι δυνατή η σύνδεση του ποιος ψήφισε με το τι ψήφισε) και τα αποτελέσματα γίνονται ορατά.
    
    


\begin{figure}[H]
\centering
\begin{lstlisting}[float]


export circuit create_voting(): [] {
    const organizer_public_key = disclose(public_key(local_secret_key()));

    assert (university_public_key != organizer_public_key,
        "University cannot create votings");

    assert (prove_eligibility(), 
        "Not authorized!");

    const voting_id = generate_voting_id(count, local_secret_key());

    voting_organizers.insert(disclose(voting_id), organizer_public_key);
    votings.insert(disclose(voting_id));
    voting_states.insert(disclose(voting_id), VOTE_STATE.open);
    voting_options.insert(disclose(voting_id), default<Set<Bytes<32>>>);
    voting_results.insert(disclose(voting_id), default<Map<Bytes<32>, Counter>>);
    count.increment(1);
}

export circuit edit_question(voting_id: Bytes<32>, voting_question: Opaque<"string">): [] {
    const organizer_public_key = disclose(public_key(local_secret_key()));
    assert (prove_eligibility(),
        "Not authorized");
    assert (voting_organizers.lookup(disclose(voting_id)) == organizer_public_key,
        "Not authorized");   
    voting_questions.insert(disclose(voting_id), disclose(voting_question));
}

export circuit add_option(voting_id: Bytes<32>, vote_option: Bytes<32>): [] {
    const organizer_public_key = public_key(local_secret_key());   
    assert (prove_eligibility(),
        "Not authorized");

    assert (voting_organizers.lookup(disclose(voting_id)) == organizer_public_key,
        "Not authorized");   
    voting_options.lookup(disclose(voting_id)).insert(disclose(vote_option));
    voting_results.lookup(disclose(voting_id)).insert(disclose(vote_option), default<Counter>);

}


export circuit close_voting(voting_id: Bytes<32>): [] {
    const organizer_public_key = public_key(local_secret_key());
    assert (prove_eligibility(),
        "Not authorized");   
    assert (voting_organizers.lookup(disclose(voting_id)) == organizer_public_key,
        "Not authorized");       
    const current_voting_state = voting_states.lookup(disclose(voting_id));
    assert (current_voting_state == VOTE_STATE.open,
        "Voting phase is not open or has already closed");    
    voting_states.insert(disclose(voting_id), VOTE_STATE.closed);
}

export circuit open_voting(voting_id: Bytes<32>): [] {
    const organizer_public_key = public_key(local_secret_key());
    assert (prove_eligibility(),
        "Not authorized");    
    assert (voting_organizers.lookup(disclose(voting_id)) == organizer_public_key,
        "Not authorized");       
    const current_voting_state = voting_states.lookup(disclose(voting_id));
    assert (current_voting_state == VOTE_STATE.closed,
        "Voting phase is not closed or has already opened");    
    voting_states.insert(disclose(voting_id), VOTE_STATE.open);
}


export circuit cast_vote(voting_id: Bytes<32>): [] {
    const current_voting_state = voting_states.lookup(disclose(voting_id));
    assert (current_voting_state == VOTE_STATE.open, 
        "Voting is not open");
    const voter_public_key = disclose(public_key(local_secret_key()));
    assert (prove_eligibility(), 
        "Not authorized!");
    const voting_nullifier = disclose(nullifier(local_secret_key(), voting_id));
    assert (!voting_nulifiers.member(voting_nullifier),
        "Already voted for this voting");
    voting_nulifiers.insert(disclose(voting_nullifier));
    const hashed_vote = disclose(hash_secret_vote(secret_vote(voting_id), voting_id, local_secret_key()));
    hashed_votes.insert(disclose(hashed_vote));


}

export circuit publish_vote(voting_id: Bytes<32>): [] {
    const current_voting_state = voting_states.lookup(disclose(voting_id));
    assert (current_voting_state == VOTE_STATE.closed, 
        "Voting is not closed");
    assert (prove_eligibility(), 
        "Not authorized!");   
    const publish_voting_nullifier = disclose(publish_nullifier(local_secret_key(), voting_id));
    assert (!publish_voting_nulifiers.member(publish_voting_nullifier),
        "Already published the vote for this voting");    

    const hashed_vote = disclose(hash_secret_vote(secret_vote(voting_id), voting_id, local_secret_key()));
    assert (hashed_votes.member(disclose(hashed_vote)),
        "Vote not correct!");     
    assert (voting_options.lookup(disclose(voting_id)).member(disclose(secret_vote(voting_id))),
        "Not a valid option!");

    voting_results.lookup(disclose(voting_id)).lookup(disclose(secret_vote(voting_id))).increment(1);
    publish_voting_nulifiers.insert(publish_voting_nullifier);

}

\end{lstlisting}
\caption{Τα impure circuits του smart contract}
\end{figure}


\section{Ανάλυση του κώδικα της  dapp}
\subsection{Από Compact σε Typescript}
Μετά την μεταγλώττιση του contract, δημιουργείται για κάθε impure circuit το αντίστοιχο .zkir αρχείο που είναι μια αναπαράσταση του κυκλώματος μηδενικής γνώσεις, καθώς και τα αρχεία .prover και .verifier που αποτελούν τα κλειδιά απόδειξης και επαλήθευσης του πρωτόκολλου μηδενικής γνώσης. Επίσης, δημιουργείται αρκετός κώδικα Typescript ο οποίος μπορεί να θεωρηθεί ως μαύρο κουτί καθώς πραγματοποιεί low-level διεργασίες όπως η υλοποίηση των κυκλωμάτων μηδενικής γνώσης. Ωστόσο, σημαντικό είναι το αρχείο \textit{index.d.ts} που δημιουργεί απαραίτητους τύπους για τη συνέχεια. Εστιάζουμε στον τύπο \textit{Ledger} που ουσιαστικά είναι η αναπαράσταση σε Typescript της public state, καθώς περιέχει σαν πεδίο κάθε ledger μεταβλητή που ορίστηκε στο contract. Με αυτό τον τρόπο, η εφαρμογή μπορεί να έχει πρόσβαση στην public state. Επίσης η κλάση \textit{Contract} περιέχει τους witnesses, όλα τα circuits, τον constructor του contract και την αρχική κατάσταση.

\begin{lstlisting}[]
export type Ledger = {
  readonly count: bigint;
  readonly university_public_key: Uint8Array;
  votings: {
    isEmpty(): boolean;
    size(): bigint;
    member(elem_0: Uint8Array): boolean;
    [Symbol.iterator](): Iterator<Uint8Array>
  };
  voting_options: {
    isEmpty(): boolean;
    size(): bigint;
    member(key_0: Uint8Array): boolean;
    lookup(key_0: Uint8Array): {
      isEmpty(): boolean;
      size(): bigint;
      member(key_1: string): boolean;
      lookup(key_1: string): string;
      [Symbol.iterator](): Iterator<[string, string]>
    }
  };
  voting_questions: {
    isEmpty(): boolean;
    size(): bigint;
    member(key_0: Uint8Array): boolean;
    lookup(key_0: Uint8Array): string;
    [Symbol.iterator](): Iterator<[Uint8Array, string]>
  };
  voting_results: {
    isEmpty(): boolean;
    size(): bigint;
    member(key_0: Uint8Array): boolean;
    lookup(key_0: Uint8Array): {
      isEmpty(): boolean;
      size(): bigint;
      member(key_1: string): boolean;
      lookup(key_1: string): { read(): bigint }
    }
  };
  eligible_voters: {
    isFull(): boolean;
    checkRoot(rt_0: { field: bigint }): boolean;
    root(): __compactRuntime.MerkleTreeDigest;
    firstFree(): bigint;
    pathForLeaf(index_0: bigint, leaf_0: Uint8Array): __compactRuntime.MerkleTreePath<Uint8Array>;
    findPathForLeaf(leaf_0: Uint8Array): __compactRuntime.MerkleTreePath<Uint8Array> | undefined;
    history(): Iterator<__compactRuntime.MerkleTreeDigest>
  };
  voting_states: {
    isEmpty(): boolean;
    size(): bigint;
    member(key_0: Uint8Array): boolean;
    lookup(key_0: Uint8Array): VOTE_STATE;
    [Symbol.iterator](): Iterator<[Uint8Array, VOTE_STATE]>
  };
  voting_nulifiers: {
    isEmpty(): boolean;
    size(): bigint;
    member(elem_0: Uint8Array): boolean;
    [Symbol.iterator](): Iterator<Uint8Array>
  };
  voting_organizers: {
    isEmpty(): boolean;
    size(): bigint;
    member(key_0: Uint8Array): boolean;
    lookup(key_0: Uint8Array): Uint8Array;
    [Symbol.iterator](): Iterator<[Uint8Array, Uint8Array]>
  };
}

export declare class Contract<T, W extends Witnesses<T> = Witnesses<T>> {
  witnesses: W;
  circuits: Circuits<T>;
  impureCircuits: ImpureCircuits<T>;
  constructor(witnesses: W);
  initialState(context: __compactRuntime.ConstructorContext<T>,
               eligible_voter_public_keys_0: Uint8Array[]): __compactRuntime.ConstructorResult<T>;
}
\end{lstlisting}


\subsection{Το api}
Έχοντας διαθέσιμους όλους τους απαραίτητους τύπος που έχουν προκύψει από τη μεταγλώττιση της Compact σε Typescript, σημαντικό ρόλο στην εφαρμογή κατέχει το api το οποίο ουσιαστικά λειτουργεί ως μια διεπαφή μέσω της οποίας ο χρήστης μπορεί να δημοσιεύσει ένα contract, να αναζητήσει ένα ήδη δυμοσιευμέυνο contract και να πραγματοποιήσει τα διαθέσιμα transcations του contract στο δίκτυο. Συγκεκριμένα, το api περιέχει το interface \textit{DeployedVoteGuardianAPI} που περιλαμβάνει την διεύθυνση του contract, την κατάστασή του, και όλα τα transactions ως typescript συναρτήσεις αλλά με τα ίδια ορίσματα και αντίστοιχους τύπους επιστροφής με τα ανάλογα της compact.

\begin{figure}[h]
\centering
\begin{lstlisting}[language=TypeScript] 
export interface DeployedVoteGuardianAPI {
  readonly deployedContractAddress: ContractAddress;
  readonly state$: Observable<VoteGuardianDerivedState>;

  cast_vote: (voting_id: Uint8Array, encrypted_vote: string) => Promise<void>;
  close_voting: (voting_id: Uint8Array) => Promise<void>;
  open_voting: (voting_id: Uint8Array) => Promise<void>;
  edit_question: (voting_id: Uint8Array, vote_question: string) => Promise<void>;
  create_voting: () => Promise<void>;
  add_option: (voting_id: Uint8Array, vote_option: string, index: string) => Promise<void>;
}
\end{lstlisting}

\caption{Το DeployedVoteGuardianAPI interface}
\end{figure}


Η κλάση \textit{VoteGuardianAPI} υλοποιεί το παραπάνω interface, αρχικοποιοώντας την κατάστασή του με την τρέχουσα κατάσταση που υπάρχει στο contract και τη διεύθυνσή του με τη διεύθυνση του contract. Για κάθε transaction παρέχεται η υλοποίησή του, η οποία στον πυρήνα της καλεί την αντίστοιχη συνάρτηση που έχε προκύψει από την compact έχοντας μεταγλωττιστεί σε typescript. Ενδεικτικά, παρουσιάζουμε την υλοποίηση του transaction edit\_question καθώς η λογική είναι ίδια στα υπόλοιπα.

\begin{figure}[h]
\centering
\begin{lstlisting}[language=TypeScript] 
async edit_question(voting_id: Uint8Array, vote_question: string): Promise<void> {
    try {
      this.logger?.info(`vote question: ${vote_question}`);
      const txData = await this.deployedContract.callTx.edit_question(voting_id, vote_question);

      this.logger?.trace({
        transactionAdded: {
          circuit: 'edit_question',
          txHash: txData.public.txHash,
          blockHeight: txData.public.blockHeight,
        },
      });
    } catch (error) {
      console.log(error);
      this.logger?.error('Error editing a question', {
        message: (error as Error).message,
        stack: (error as Error).stack,
        details: error,
      });
    }
  }
\end{lstlisting}

\caption{Η κλήση του cast\_vote μέσω typescript}
\end{figure}
\newpage
\newpage


Επίσης, η κλάση \textit{VoteGuardianAPI} παρέχει δύο στατικές μεθόδους, την \textit{deploy} για δημοσίευση ενός contract και την \text{join} για την αναζήτηση ενός contract και συμμετοχή σε αυτό. Και οι δύο αυτές μέθοδοι επιστρέφουν ένα αντικείμενο της κλάσης \textit{VoteGuardianAPI}. Και οι δύο αυτές μέθοδοι πρέπει να αρχικοποιήσουν την private state καθώς όταν κάποιος είτε δημοσιεύει ένα contract είτε κάνει join σε αυτό, πρέπει να έχει μια αρχική private state. Στη δική μας περίπτωση, όπως έχουμε πει η private state αποτελείται από το secret key και από το έγκυρο μονοπάτι μέσα στο merkle tree. Το secret key δίνεται ως όρισμα στις deploy, join ώστε ο χρήστης που τις καλεί να δώσει το δικό του secret key (ως γνωστόν δε φεύγει ποτέ από το δικό του υπολογιστή), ενώ ως merkle path δίνεται μια dummy τιμή με μηδενικά, καθώς σε αυτό το σημείο δε μας νοιάζει να είναι έγλυρο το path. Η αλλαγή στην private state  και συγκεκριμένα στην find\_voter\_public\_key θα πραγματοποιείται κάθε φορά που ο χρήστης πραγματοποιεί transaction που απαιτεί αυθεντικοποίηση. Παραθέτουμε την υλοποίηση της \text{join}.


\begin{figure}[h]
\centering
\begin{lstlisting}[language=TypeScript] 
 static async join(
    providers: VoteGuardianProviders,
    contractAddress: ContractAddress,
    secretKey: string,
    logger?: Logger,
  ): Promise<VoteGuardianAPI> {
    logger?.info({
      joinContract: {
        contractAddress,
      },
    });

    const deployedVoteGuardianContract = await findDeployedContract(providers, {
      contractAddress,
      contract: VoteGuardianContractInstance,
      privateStateId: 'voteGuardianPrivateState',
      initialPrivateState:
        // (await providers.privateStateProvider.get('voteGuardianPrivateState')) ??
        createVoteGuardianPrivateState(utils.hexToBytes(secretKey), {
          leaf: new Uint8Array(32),
          path: [
            {
              sibling: { field: BigInt(0) },
              goes_left: false,
            },
          ],
        }),
    });

    logger?.trace({
      contractJoined: {
        finalizedDeployTxData: deployedVoteGuardianContract.deployTxData.public,
      },
    });

    return new VoteGuardianAPI(deployedVoteGuardianContract, providers, logger);
  }
\end{lstlisting}

\caption{Η στατική μέθοδος join της κλάσης VoteGuardianApi}
\end{figure}



\subsection{Το user interface}
Το user interface της εφαρμογής γράφτηκε χρησιμοποιώντας \textit{ReactJS} και στην ουσία αξιοποιεί τους τύπους και τα αντικείμενα που προσφέρονται από το api και από τον κώδικα Typescript που παράγεται από την compact. Εκτενής παρουσίαση του interface θα γίνει σε επόμενο κεφάλαιο, παρουσιάζοντας διάφορες περιπτώσεις χρήσης. Ωστόσο, μια σημαντική λειτουργία που πραγματοποιείται από τον κώδικα του ui είναι η αρχικοποίηση σημαντικών παραμέτρων, οι οποίες ονομάζονται \textbf{providers} για την σωστή λειτουργία της εφαρμογής στο Midnight, όπως είναι η σύνδεση του Lace Wallet με την εφαρμογή, η διαχείριση της private state κάθε χρήστη και η σύνδεση με τον proofServer. Αυτές οι λειτουργίες πραγματοποιούνται μέσω της συνάρτησης \textit{initializeProviders} που φαίνεται στο σχήμα 3.9. Συγκεκριμένα αυτή η συνάρηση:
\begin{enumerate}
    \item Επιστρέφει τιμή τύπου MidnightProviders.
    \item Ως privateStateProvider, δηλαδή ως μέσο αποθήκευσης της private state κάθε χρήστη ορίζει τη level-db του browser της οποίας η υλοποίηση έρχεται από τη βιβλιοθήκη του Midnight.
    \item Ορίζει ως proof server αυτόν που έχει ορίσει ο χρήστης μέσω του wallet του, δηλώνοντας εκεί τη διεύθυνση στην οποία τρέχει ο proof server (η οποία είναι συνήθως localhost:6000).
    \item Δηλώνει τη διεύθυνση του indexer, δηλαδή του συστατικού εκείνου μέσω του οποίου γίνεται η αναζήτηση για δεδομένα στο δίκτυο, δεδομένα όπως η public state του contract. Τη διεύθυνση του indexer τη δίνει ο χρήστης μέσω του lace wallet.
    \item Συνδέει το lace wallet με την εφαρμογή, αρχικοποιώντας τον walletProvider.
    \item Δηλώνει από που θα λαμβάνονται τα κλειδιά και τα circuits που αφορούν τις αποδείξεις μηδενικής γνώσεις, αρχικοποιώντας τον zkConfigProvider.
    \item Αρχικοποιεί τον midnightProvider ώστε να μπορούν να πραγματοποιούνται transactions στο Midnight.
    
\end{enumerate}



\begin{figure}[h]
\centering
\begin{lstlisting}[language=TypeScript] 
const initializeProviders = async (logger: Logger): Promise<VoteGuardianProviders> => {
  const { wallet, uris } = await connectToWallet(logger);
  const walletState = await wallet.state();

  return {
    privateStateProvider: levelPrivateStateProvider({
      privateStateStoreName: 'voteGuardian-private-state',
    }),
    zkConfigProvider: new FetchZkConfigProvider(window.location.origin, fetch.bind(window)),
    proofProvider: httpClientProofProvider(uris.proverServerUri),
    publicDataProvider: indexerPublicDataProvider(uris.indexerUri, uris.indexerWsUri),
    walletProvider: {
      coinPublicKey: walletState.coinPublicKey,
      encryptionPublicKey: walletState.encryptionPublicKey,
      balanceTx(tx: UnbalancedTransaction, newCoins: CoinInfo[]): Promise<BalancedTransaction> {
        return wallet
          .balanceTransaction(
            ZswapTransaction.deserialize(tx.serialize(getLedgerNetworkId()), getZswapNetworkId()),
            newCoins,
          )
          .then((tx) => wallet.proveTransaction(tx))
          .then((zswapTx) => Transaction.deserialize(zswapTx.serialize(getZswapNetworkId()), getLedgerNetworkId()))
          .then(createBalancedTx);
      },
    },
    midnightProvider: {
      submitTx(tx: BalancedTransaction): Promise<TransactionId> {
        return wallet.submitTransaction(tx);
      },
    },
  };
};
\end{lstlisting}

\caption{Η αρχικοποίηση των Midnight Providers}
\end{figure}

\section{Ανάλυση του server του πανεπιστημίου}
\subsection{Αυθεντικοποίηση των φοιτητών}
Στην αρχική οθόνη της εφαρμογής υπάρχει η επιλογή Authenticate μέσω της οποίας πραγματοποιείται η αυθεντικοποίηση των έγκυρων ψηφοφόρων. Η διαδικασία έχει ως εξής:
\begin{enumerate}
    \item Ο χρήστης καταχωρεί τα στοιχεία του, δηλαδή username και password, ενώ ταυτόχρονα υπολογίζεται μια τυχαία συμβολοσειρά από 32 byte η οποία θα είναι το υποψήφιο secret key του χρήστη. Ο χρήστης δεν αναμειγνύεται στη δημιουργία αυτής της συμβολοσειράς, αντιθέτως γίνεται αυτόματα από τν κώδικα της dapp.
    \item Έχοντας υπολογίσει το υποψήφιο secret key, υπολογίζεται και το hash του μέσω της συνάρτησης καρακερματισμού sha256 και στέλνεται http request στο endpoint του server του πανεπιστημίου /login.
    \item Αν για τον συγκεκριμένο χρήστη, δηλαδή για το συγκεκριμένο ζεύγος username, password δεν υπάρχει καταχωρημένη τιμή στο πεδίο publicKey, σημαίνει πως ο χρήστης πρώτη φορά αυθεντικοποιείται, συνεπώς η διαδικασία είναι επιτυχής. Ταυτόχρονα εμφανίζεται στον χρήστη το secret key του με προτροπή να το αποθηκεύσει κάπου με ασφάλεια. Είναι σημαντικό να τονίσουμε εδώ ότι το secret key δεν φεύγει ποτέ από το τοπικό περιβάλλον του χρήστη, διότι υπολογίζεται τοπικά και αποστέλεται με request μόνο το hash του.
    \item Αν ο χρήστης δεν υπάρχει στη βάση ή αν έχει ήδη δηλώσει κάποιο άλλο secret key τότε η διαδικασία αποτυγχάνει και εμφανίζεται αντίστοιχο μήνυμα λάθους.
\end{enumerate}
Σημειώνουμε ότι υπάρχει και ένα δεύτερο endpoint που παρέχει ο server του πανεπιστημίου, το /register, μέσω του οποίου καταχωρούνται οι φοιτητές στη βάση δεδομένων

\subsection{Δημοσίευση του smart contract από το πανεπιστήμιο}
Όπως έχουμε προαναφέρει η συμμετοχή του πανεπιστημίου στο σύστημα έγγειται στη δημιουργία και δημοσίευση του smart contract στο Midnight, έχοντας συγκεντρώσει τα public keys των έγγυρων χρηστών από τη βάση δεδομένων. Για να δημοσιεύσει ένα smart contract στο Midnight, το πανεπιστήμιο θα πρέπει να τρέξει τοπικά τον proof server όπως και όλοι οι voters ενώ θα χρειαστεί να έχει το δικό του wallet, καθώς το deploy ενός smart contract στο δίκτυο χρεώνεται. Καθώς όμως το πανεπιστήμιο δεν έχει user interface, δε θα χρησιμοποιήσει το lace wallet, αντιθέτως θα δημιουργήσει ένα δικό του wallet μέσω βιβλιοθηκών του Midnight, το οποίο ωστόσο θα έχει τις ίδιες δυνατότητες με το lace wallet. 

\begin{figure}[h]
\centering
\begin{lstlisting}[language=TypeScript] 
const wallet = await buildWallet(config, rli, logger);

try {
  if (wallet !== null) {
    const walletAndMidnightProvider = await createWalletAndMidnightProvider(wallet);
    const providers = {
      privateStateProvider: inMemoryPrivateStateProvider<'voteGuardianPrivateState', VoteGuardianPrivateState>(),

      publicDataProvider: indexerPublicDataProvider(config.indexer, config.indexerWS),

      zkConfigProvider: new NodeZkConfigProvider<
        'cast_vote' | 'close_voting' | 'create_voting' | 'add_option' | 'open_voting' | 'edit_question' | 'publish_vote'
      >(config.zkConfigPath),
      proofProvider: httpClientProofProvider(config.proofServer),
      walletProvider: walletAndMidnightProvider,
      midnightProvider: walletAndMidnightProvider,
    };
    await mainLoop(providers, rli, logger);
  }
}
\end{lstlisting}

\caption{Η δημιουργία του wallet και των providers από το πανεπιστήμιο}
\end{figure}

Καλλώντας την μέθοδο buildWallet το πανεπιστήμιο κατασκευάζει ένα wallet με ίδιες δυνατότητες με αυτές του lace wallet. Στη συνέχεια, δημιουργείται το αντικείμενο providers που περιέχει όλες τις ιδιότητες που χρειάζονται για τη δημιουργία ενός smart contract. Η δημιουργία του smart contract γίνεται μέσω της mainLoop.


\begin{figure}[h]
\centering
\begin{lstlisting}[language=TypeScript] 
const mainLoop = async (providers: VoteGuardianProviders, rli: Interface, logger: Logger): Promise<void> => {
  const secretKeyBytes = new Uint8Array(32);
  const secretKey = toHex(secretKeyBytes);


  let eligibleVoters = [];
  const users = await User.find({}).select('publicKey -_id');

  eligibleVoters = users.map((user) => user.publicKey);
  const eligibleVotersUint8: Uint8Array[] = eligibleVoters.map((voterStr) => {
    return stringToUint8Array(voterStr!);
  });

  const contractAddressFile = path.resolve(process.cwd(), 'contract_address.txt');
  const contractAddress = fs.readFileSync(contractAddressFile, 'utf8').trim();
  let VoteGuardianApi: VoteGuardianAPI | null;

  if (contractAddress) {
    VoteGuardianApi = await VoteGuardianAPI.join(providers, contractAddress, secretKey, logger);
  } else {
    VoteGuardianApi = await VoteGuardianAPI.deploy(providers, secretKey, eligibleVotersUint8, logger);
  }

  if (VoteGuardianApi === null) {
    return;
  }
  console.log(`deployed - joined at address ${VoteGuardianApi.deployedContractAddress}`);

  fs.writeFileSync(contractAddressFile, VoteGuardianApi.deployedContractAddress, 'utf8');
  let currentState: VoteGuardianDerivedState | undefined;
  const stateObserver = {
    next: (state: VoteGuardianDerivedState) => (currentState = state),
  };
  const subscription = VoteGuardianApi.state$.subscribe(stateObserver);
};
\end{lstlisting}

\caption{Η mainLoop}
\end{figure}

Αρχικά το πανεπιστήμιο βρίσκει από τη βάση δεδομένων όλα τα public keys των φοιτητών και τα αποθηκεύει στη μεταβλητή eligibleVoters. Αν έχει ήδη δημοσιεύσει κάποιο smart contract τότε χρησιμοποιεί τη μέθοδο join για εύρεση αυτού του smart contract. Αν είναι η πρώτη φορά που δημοσιεύεται κάποιο smart contract τότε χρησιμοποιεί τη μέθοδο deploy του VoteGuardianApi δίνοντας ως παραμέτρους τους providers, ένα τυχαίο secret key το οποίο χρησιμοποιείται ως placeholder και έναν πίνακα με τα public keys των ψηφοφόρων. Παραθέτουμε την υλοποίηση της deploy.

\begin{figure}[h]
\centering
\begin{lstlisting}[language=TypeScript] 
static async deploy(
    providers: VoteGuardianProviders,
    secretKey: string,
    eligibleVoterPublicKeys: Uint8Array[],
    logger?: Logger,
  ): Promise<VoteGuardianAPI | null> {
    try {

      const DeployedVoteGuardianContract = await deployContract(providers, {
        privateStateId: 'voteGuardianPrivateState',
        contract: VoteGuardianContractInstance,
        initialPrivateState: createVoteGuardianPrivateState(
          utils.hexToBytes(secretKey),
          {
            leaf: new Uint8Array(32),
            path: [
              {
                sibling: { field: BigInt(0) },
                goes_left: false,
              },
            ],
          },
          new Map<String, String>(),
        ),
        args: [eligibleVoterPublicKeys],
      });


      logger?.trace({
        contractDeployed: {
          finalizedDeployTxData: DeployedVoteGuardianContract.deployTxData.public,
        },
      });

      return new VoteGuardianAPI(DeployedVoteGuardianContract, providers, logger);
    } catch (error) {
      console.log((error as Error));
      return null;
    }
\end{lstlisting}

\caption{Η μέθοδος deploy}
\end{figure}

Η μέθοδος deploy χρησιμοποιεί τη συνάρτηση βιβλιοθήκης deployContract δίνοντας ως ορίσματα τα public keys των φοιτητών (που χρησιμοποιούνται στον κατασκευαστή του contract ως τα στοιχεία του Merkle Tree) καθώς και μια private state ως placeholder. Επειδή το πανεπιστήμιο δε συμμετέχει στις διαδικασίες ψηφοφορίας και δε μπορεί να πραγματοποιήσει transactions, όλες οι witness μεταβλητές αρχικοποιούνται σε dummy τιμές. Μόνος σκοπός του πανεπιστημίου είναι να δημοσιεύει το smart contract.














\newpage
\chapter{Περιπτώσεις Χρήσης}
Σε αυτό το κεφάλαιο θα παρουσιάσουμε τις περιπτώσεις χρήσης της εφαρμογής, δείχνοντας πώς οι χρήστες μπορούν να την αξιοποιήσουν για να πραγματοποιήσουν τα διαθέσιμα transactions, δημιουργώντας νέες ψηφοφορίες, πραγματοποιώντας αλλαγές σε αυτές και συμμετέχοντας σε αυτές με την ψήφο τους. Με αυτόν τον τρόπο θα επιβεβαιώσουμε στην πράξη ότι οι κανόνες που έχουν οριστεί από το smart contract εφαρμόζονται σωστά και λειτουργούν όπως σχεδιάστηκαν.


\section{Δημιουργία Ψηφοφορίας}
Για τις επόμενες ενότητες θα δουλέψουμε το εξής σενάριο: Έχουμε δύο έγκυρους χρήστες, ας πούμε τους user1, user2 με μυστικά κλειδία ec1d0ad62fbd918ea23a151264a4de5e59ecdce87d36f84ed6402ba4077dc30b και
9f3ec6ed2544939544eb3f231247c4111ed3e5263f5613bf3d8aea4b269a1191 αντίστοιχα. Έστω επίσης πως το smart contract βρίσκεται στη διεύθυνση 0200881de6e23b631470d7c0dec45782f4c67e807955d9e44f8c4a5b9e376241c3b5.
Θεωρούμε πως αυτή η διεύθυνση είναι γνωτή και έχει κοινοποιηθεί από το πανεπιστήμιο στους φοιτητές.

\subsection{Είσοδος στην dapp}
Όπως έχουμε ήδη εξηγήσει, κάθε φοιτητής μπορεί να δημιουργήσει ψηφοφορίες. Στην αρχική σελίδα της εφαρμογής ο χρήστης πρέπει να συμπληρώσει τη διεύθυνση του smart contract. Επίσης, ο φοιτητης συμπληρώνει το secret key του, ώστε να αρχικοποιηθεί η private state του. Σημειώνεται εδώ πως το secret key ποτέ δε "φεύγει" από τον υπολογιστή του χρήστη.΄Έστω λοιπόν πως ο user1 συνδέεται στην εφαρμογή, δίνοντας αρχικά τη διεύθυνση του smart contract καθώς και το secret key του, όπως φαίνεται στα σχήματα \ref{fig:enter_contract_new} και \ref{fig:enter_secret_key2}.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{landpage.png}
  \caption{Η αρχική οθόνη της dapp}
  \label{fig:diag}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{enter_contract_new.png}
  \caption{Ο χρήστης user1 συμπληρώνει τη διεύθυνση του smart contract}
  \label{fig:enter_contract_new}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{enter_secret_key2.png}
  \caption{Ο χρήστης user1 συμπληρώνει το secret key του}
  \label{fig:enter_secret_key2}
\end{figure}
Στη συνέχεια, ο χρήστης οδηγείται στην αρχική οθόνη του smart contract όπου μπορεί να δει τις διαθέσιμες ψηφοφορίες ή να δημιουργήσει ο ίδιος μία, βλ. σχήμα \ref{fig:create_or_view}.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{create_or_view.png}
  \caption{Η αρχική οθόνη του smart contract}
  \label{fig:create_or_view}
\end{figure}
\subsection{Δημιουργία ψηφοφορίας}
Καθώς δεν υπάρχουν ακόμα ψηφοφορίες, ο χρήστης επιλέγει τη δημιουργία μιας νέας ψηφοφορίας μέσω του transaction create\_voting. Με αυτή την επιλογή, θα εμφανιστεί το παράθυρο του lace wallet όπου ο χρήστης πρέπει να υπογράψει το transaction. Αυτό γίνεται σε κάθε transaction που πραγματοποιεί ο χρήστης και φαίνεται στο σχήμα \ref{fig:sign_transaction}.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{sign_transaction.png}
  \caption{Η υπογραφή ενός transaction με το lace wallet}
  \label{fig:sign_transaction}
\end{figure}
Έχοντας δημιουργήσει την ψηφοφορία και επιστρέφοντας στην αρχική οθόνη, αν ο χρήστης επιλέξει την επιλογή VIEW VOTINGS τότε μπορεί να δει αυτή την ψηφοφορία, η οποία δεν έχει κάποια ερώτηση, και για αυτό αναγράφεται η ένδειξη "No question yet". Αυτό φαίνεται στο σχήμα \ref{fig:no_question_yet}.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{no_question_yet.png}
  \caption{Η αρχικά άδεια δημιουργημένη ψηφοφορία}
  \label{fig:no_question_yet}
\end{figure}
Επιλέγοντας τη συγκεκριμένη ψηφοφορία, ο χρήστης οδειγήτεαι στο μενού της, όπου υπάρχει η ακόλουθη εικόνα.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{voting_menu.png}
  \caption{Η αρχικά άδεια δημιουργημένη ψηφοφορία}
  \label{fig:voting_menu}
\end{figure}

Ο χρήστης μπορεί να ανοίξει ή να κλείσει την ψηφοφορία ανάλογα με την κατάσταση της, μπορεί να προσθέσει την ερώτηση της ψηφοφορίας, να προσθέσει επιλογές, να ψηφίσει, να δημοσιεύεσει την ψήφο του, να δει τα αποτελέσματα της ψηφοφορίας (τα οποία όπως έχουμε εγηγήσει εμφανίζονται μετά την λήξη της έχοντας εκτελέσει publish\_vote) και να δει την ψήφο που έχει επιλέξει για τη συγκεκριμένη ψηφοφορία. 

\subsection{Προσθήκη ερώτησης}
Ο χρήστης επιλέγει το κουμπί QUESTION οπότε οδηγείται στο μενού επεξεργασίας της ερώτησης όπως φαίνεται στο σχήμα \ref{fig:edit_question}. Ας πούμε πως η ερώτηση είναι η question1.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{edit_question.png}
  \caption{Ο χρήστης user1 δημιουργεί την ερώτηση question1}
  \label{fig:edit_question}
\end{figure}

\subsection{Προσθήκη επιλογών}
Με την ίδια λογική ο χρήστης προσθέτει στην ψηφοφορία δύο διαθέσιμες επιλογές, τις option1 και opption2.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{option1_option2.png}
  \caption{Ο χρήστης user1 δημιουργεί τις επιλογές option1, option2}
  \label{fig:option1_option2}
\end{figure}

\subsection{Τελική εικόνα}
Τώρα αφού τελειώσαμε με την δημιουργία ψηφοφορίας από τον χρήστη user1, όπως είπαμε προηγουμένως υπάρχει και ο χρήστης user2. Με ακριβώς παρόμοια βήματα με τα προηγούμενα, ο user2 δημιουργεί μια νέα ψηφοφορία με ερώτηση την question2 και επιλογές τις option11, option22. Στο τέλος, η εικόνα που υπάρχει στο smart contract είναι 2 ανοικτές ψηφοφορίες, και αυτό φαίνεται στην αρχική οθόνη, επιλέγοντας το κουμπί VIEW VOTINGS.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{view_votings_q1q2.png}
  \caption{Η εικόνα του smart contract με δύο ανοικτές ψηφοφορίες}
  \label{fig:view_votings_q1q2}
\end{figure}

\subsection{Κακόβουλη χρήση}
Για να δείξουμε και μερικές περιπτώσεις κακόυβουλης χρήσης, ας υποθέσουμε ότι ο user1 θέλει να τροποποιήσει την ψηφοφορία που δημιούργησε ο user1 προσθέτοντας μια επιλογή, και ας υποθέσουμε επίσης ότι ο user2 Θέλει να κάνει το αντίστοιχο στην ψηφοφορία του user1, τροποποιώντας την ερώτηση. Και στις δύο περιπτώσεις θα εμφανιστεί μήνυμα λάθους, το οποίο προέρχεται από τα assert statements του smart contract, όπως φαίνεται στα δύο επόμενα σχήματα.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{user1_tries_to_edit_question_on_Vote2_failed.png}
  \caption{Ο user1 προσπαθεί να αλλάξει την ερώτηση της ψηφοφορίας που ανήκει στον user2}
  \label{fig:user1_tries_to_edit_question_on_Vote2_failed}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{user2_tries_to_add_option_to_voting1_failed.png}
  \caption{Ο user2 προσπαθεί να προσθέσει μια επιλογή στην ψηφοφορία που ανήκει στον user1}
  \label{fig:user2_tries_to_add_option_to_voting1_failed}
\end{figure}

Μια άλλη περίπτωση κακόβουλης χρήσης είναι ένας μη έγκυρος χρήστης, δηλαδή ένας χρήστης του οποίου το hash(secret key) δεν ανήκει στο στο Merkle Tree με τους έγκυρους ψηφοφόρους, να προσπαθήσει να δημιουργήσει μια ψηφοφορία εκτελώντας το transcation create\_voting. Όπως έχουμε δει από την υλοποίηση του σχετικού circuit, θα αποτύχει ο έλεγχος prove\_eligibility και θα εμφανιστεί μήνυμα λάθους όπως φαίνεται παρακάτω.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{user_outside_merkle_tree_tries_to_create_voting.png}
  \caption{Μη έγκυρος χρήστης προσπαθεί να δημιουργήσει μια ψηφοφορία}
  \label{fig:user_outside_merkle_tree_tries_to_create_voting}
\end{figure}



\section{Ψήφος σε Ψηφοφορία}
Σε αυτή την ενότητα θα συνεχίσουμε με το παράδειγμα που ξεκινήσαμε προηγουμένως και θα δούμε τους δύο χρήστες να ψηφίζουν σε ψηφοφορίες, αλλά και το πως η εφαρμοφή απαγορεύει το double-voting με κατάλληλα μηνύματα λάθους.

\subsection{Φυσιολογική ροή}
Αρχικά, ο χρήστης user1 ψηφίζει την επιλογή option1 στην ψηφοφορία που δημιούργησε. Ωστόσο, πριν το κάνει αυτό, βλέπουμε πως επιλέγοντας την επιλογή DISPLAY VOTE στο μενόυ της ψηφοφορίας, φαίνεται πως δεν υπάρχει καταχωρημένη κάποια ψήφος, βλ. σχήμα \ref{fig:user2_votes_on_question1_no_vote}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{user2_votes_on_question1_no_vote.png}
  \caption{Ο user1 πριν ψηφίσει στην ψηφοφορία που δημιούργησε}
  \label{fig:user2_votes_on_question1_no_vote}
\end{figure}
Στη συνέχεια επιλέγει την επιλογή VOTE και ψηφίζει το option1 και τώρα στο μενού της ψηφοφορίας, στην επιλογή DISPLAY VOTE, θα φαίνεται η επιλογή option1.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{vote_option1.png}
  \caption{Ο user1 ψηφίζει το option1 στην ψηφοφορία που δημιούργησε}
  \label{fig:vote_option1}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{display_vote_user1_option1.png}
  \caption{Ο user1 έχοντας ψηφίσει option1 στην ψηφοφορία που δημιούργησε}
  \label{fig:display_vote_user1_option1}
\end{figure}

Όπως είπαμε προηγουμένως, επειδή στο ledger καταχωρείται το hash της ψήφου και όχι η ίδια η ψήφος στο στάδιο αυτό, αν ο χρήστης επιλέξει την επιλογή SHOW RESULTS τότε δε θα φαίνεται ότι υπάρχουν καταχωρημένα αποτελέσματα, πράγμα που επιβεβαιώνεται παρακάτω:
\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{show_results_empy.png}
  \caption{Τα αποτελέσματα δε φαίνονται όσο είναι ανοιχτή η ψηφοφορία και δεν έχουν γίνει published οι ψήφοι}
  \label{fig:show_results_empy}
\end{figure}

Συμμετρικά τώρα, ο χρήστης user2 με ίδια βήματα ψηφίζει την επιλογή option2 στην ψηφοφορία του user1(question1). Επίσης, ο user1 ψηφίζει την επιλογή option11 στην ψηφοφορία του user2(question2) και ο user2 ψηφίζει την επιλογή option22. Για χάριν απλότητας παραλείπουμε τα ενδιάμεσα βήματα.

\subsection{Κακόβουλη χρήση - double-voting}
Έστω ότο ο χρήστης user1 επιλέγει να ξαναψηφίσει στην ίδια ψηφοφορία. Αν το πραγματοποιήσει αυτό, τότε ευμφανίζεται κατάλληλο μήνυμα λάθους που προέρχεται από το assert statement του cast\_vote circuit στο smart contract, το οποίο έχει αναλυτικά περιγραφεί παραπάνω.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{failed_vote_user1.png}
  \caption{Περίπτωση double-voting}
  \label{fig:failed_vote_user1}
\end{figure}

\subsection{Κακόβουλη χρήση - Μη έγκυρος χρήστης}
Ας υποθέσουμε ότι έχουμε έναν χρήστη ο του οποίου το public key δεν ανήκει στο Merkle Tree Με τους έγκυρους ψηφοφόρους. Αν αυτός ο χρήστης προσπαθήσει να ψηφίσει σε οποιαδήποτε ψηφοφορία, ακριβώς επειδή θα αποτύχει να αποδείξει ότι γνωρίζει έγκυρο μονοπάτι προς τη ρίζα του δέντρου, δεν έχει δικαίωμα να ψηφίσει και εμφανίζεται κατάλληλο μήνυμα λάθους από την εφαρμογή.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{user_outside_merkle_Tree_tries_to_vote.png}
  \caption{Μη έγκυρος χρήστης προσπαθεί να ψηφίσει}
  \label{fig:user_outside_merkle_Tree_tries_to_vote}
\end{figure}



\section{Δημοσίευση ψήφου}
Σε αυτή την ενότητα θα συνεχίσουμε το παράδειγμα που έχουμε ήδη ξεκινήσει ώστε να ολοκληρώσουμε έναν πλήρη κύκλο χρήστης της εφαρμογής, αξιοποιώντας όλες τις δυνατότητές της. 

\subsection{Φυσιολογική ροή}
Έχοντας λοιπόν και οι δύο χρήστες user1 και user2 ψηφίσει, αρχικά ο user1 κλείνει την ψηφοφορία επιλέγοντας την επιλογή CLOSE VOTING, η οποία καλεί το circuit close\_voting. Στη συνέχεια εκτελεί το transaction PUBLISH VOTE. Αντίστοιχα ο user2 εκτελεί και αυτός PUBLISH VOTE, συνεπώς η εικόνα στην επιλογή SHOW RESULTS είναι αυτή που παρουσιάζεται στο σχήμα \ref{fig:user2_publish_vote_on_vote1_results}:
\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{user2_publish_vote_on_vote1_results.png}
  \caption{Τα αποτελέσματα στην ψηφοφορία μετά την δημοσίευση και των δύο ψήφων}
  \label{fig:user2_publish_vote_on_vote1_results}
\end{figure}

Αντίστοιχη είναι και η εικόνα στην ψηφοφορία που δημιούργησε ο user2 όταν και οι δύο χρήστες δημοσιεύσουν τις ψήφους τους,

\subsection{Κακόβουλη χρήση - Δεύτερη δημοσίευση ψήφου}
Αν ο χρήστης user1 επιλέξει να εκτελέσει δεύτερη φορά το transcation publish\_vote τότε θα εμφανιστεί το αντίστοιχο μήνυμα λάθους που υπάρχει στο circuit.
\ref{fig:user1_publishes_vote_twice_on_vote1_failed}:
\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{user1_publishes_vote_twice_on_vote1_failed.png}
  \caption{Ο χρήστης user1 προσπαθεί δεύτερη φορά να δημοσιεύσει την ψήφο του}
  \label{fig:user1_publishes_vote_twice_on_vote1_failed}
\end{figure}

\subsection{Κακόβουλη χρήση - Μη έγκυρη ψήφος}
Έστω ότι έχουμε έναν χρήστη, ο οποίος αλλάζει την υλοποίηση της εφαρμογής, και θέτει στην private state του, τη μεταβλητή secret\_vote(voting\_id) να είναι μια ψήφος της επιλογής του, έστω my\_vote. Όπως έχουμε ήδη αναφέρει, η private state ανήκει στον χρήστη και δεν εκτίθεται ποτέ έξω από το τοπικό του περιβάλλον, συνεπώς μπορεί να την τροποποιήσει όπως θέλει.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{user_votes_his_own_vote.png}
  \caption{Ο χρήστης ρίχνει μια δική του ψήφο που δεν υπάρχει στις διαθέσιμες επιλογές}
  \label{fig:user_votes_his_own_vote}
\end{figure}

Το transaction cast\_vote θα πετύχει κανονικά και στη ledger μεταβλητή hashed\_votes Θα καταχωρηθεί το hash της συμβολοσειράς my\_vote. Όταν όμως ο χρήστης εκτελέσει το transaction publish\_vote, θα ελεγθεί ότι η ψήφος αυτή δεν ανήκει στο σύνολο voting\_options οπότε και θα εμφανιστεί μήνυμα λάθους που προέρχεται από το circuit publish\_vote. Αξίζει να σημειωθεί εδώ, ότι δεν είναι δυνατή η συσχέτιση της ψήφου με τον ψηφοφόρο καθώς η χρήση Merkle Trees αποτρέπει τη σύνδεση του public key με το transaction που εκτελείται.


\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{user_with_his_own_vote_tries_to_publish_it.png}
  \caption{Ο χρήστης προσπαθεί να δημοσιεύσει μη έγκυρη ψήφο}
  \label{fig:user_with_his_own_vote_tries_to_publish_it}
\end{figure}

\subsection{Κακόβουλη χρήση - Αλλαγή ψήφου}
Παρόμοια με το προηγούμενο παράδειγμα, έστω ότι έχουμε ένα χρήστη ο οποίος αρχικά επιλέγει κανονικά μία από τις διαθέσιμες επιλογές και εκτελεί το cast\_vote transaction. Το hash της έγκυρης ψήφου θα καταχωρηθεί ως γνωστόν στο hashed\_votes. 
Έστω τώρα ότι ο κακόβουλος χρήστης αλλάζει το private state του και θέτει στο secret\_vote είτε κάποια άλλη επιλογή είτε κάποια δική του. Αν εκτελέσει το transaction publish\_vote για να δημοσιεύσει την ωήφο του, τότε τα δύο hashes δε θα ταιριάζουν (δηλαδή το hash της αρχικής ψήφου και το hash της αλλαγμένης ψήφου), συνεπώς θα εμφανιστεί μήνυμα λάθους που έρχεται από το αντίστοιχο circuit.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{change_vote.png}
  \caption{Ο χρήστης άλλαξε το private state της ψήφου και προσπάθησε να δημοσιεύσει}
  \label{fig:change_vote}
\end{figure}

\chapter{Επίλογος}
Στο πλαίσιο της παρούσας διπλωματικής εργασίας καταδείξαμε πώς η τεχνολογία blockchain μπορεί να αξιοποιηθεί για την υλοποίηση μιας πραγματικά αποκεντρωμένης εφαρμογής ηλεκτρονικών ψηφοφοριών για φοιτητές. Παράλληλα, αναδείξαμε τα ουσιαστικά πλεονεκτήματα που προσφέρει το Midnight σε σχέση με τα παραδοσιακά blockchain συστήματα, εστιάζοντας ιδιαίτερα στους μηχανισμούς προστασίας των προσωπικών δεδομένων. Με τον τρόπο αυτό, διασφαλίζεται τόσο η ιδιωτικότητα της ψήφου όσο και η ανωνυμία και ακεραιότητα της ταυτότητας κάθε χρήστη, προσφέροντας ένα περιβάλλον που συνδυάζει ασφάλεια, διαφάνεια και εμπιστοσύνη — στοιχεία απαραίτητα για μια σύγχρονη και αξιόπιστη ψηφιακή διαδικασία ψηφοφορίας.

Ωστόσο, δεν εξαλείψαμε πλήρως την ανάγκη ύπαρξης μιας κεντρικής αρχής, καθώς το πανεπιστήμιο εξακολουθεί να αποτελεί τον φορέα που αναλαμβάνει την αυθεντικοποίηση των φοιτητών και τη δημοσίευση του smart contract στο δίκτυο. Με άλλα λόγια, παρότι το σύστημα βασίζεται σε αποκεντρωμένες τεχνολογίες, απαιτείται ένας έμπιστος οργανισμός για τη διασφάλιση της εγκυρότητας και της αρχικής εγκαθίδρυσης των διαδικασιών.

Κατά τη διάρκεια της μελέτης και της υλοποίησης της διπλωματικής εργασίας αντιμετωπίσαμε αρκετές προκλήσεις και δυσκολίες, ενώ σε ορισμένα σημεία χρειάστηκε να προβούμε σε συγκεκριμένες παραδοχές για να προχωρήσει ο σχεδιασμός και η ανάπτυξη του συστήματος. Παρ’ όλα αυτά, το τελικό αποτέλεσμα κρίνεται ιδιαίτερα ικανοποιητικό, καθώς ανταποκρίνεται στους στόχους που είχαν τεθεί αρχικά και προσφέρει μια ολοκληρωμένη και λειτουργική λύση.

\section{Τεχνικές Προκλήσεις}
Ένα από τα μεγαλύτερα ζητήματα ήταν η αρχική έλλειψη γνώσης σχετικά με τη λειτουργία των αποκεντρωμένων εφαρμογών και του Midnight. Συγκεκριμένα, έπρεπε να κατανοήσω πώς λειτουργεί η γλώσσα Compact, πώς συνδέεται με την TypeScript, αλλά και το μοντέλο διαχείρισης κατάστασης του Midnight, το οποίο διαχωρίζει ξεκάθαρα την private state από την public state. Ήταν απαραίτητο να μελετήσω σε βάθος την τεκμηρίωση και να συζητήσω με ανθρώπους που εργάζονται στον χώρο, ώστε να κατανοήσω καλύτερα τον τρόπο με τον οποίο λειτουργεί ολόκληρο το οικοσύστη,α. Μέσα από αυτή τη διαδικασία απέκτησα σαφή κατανόηση των μηχανισμών που διέπουν τη λειτουργία του Midnight και κατάφερα να προχωρήσω στην ανάπτυξη των απαιτούμενων λειτουργιών της εφαρμογής.

\section{Περιορισμοί - Παραδοχές}
Όπως αναφέραμε, λόγω της δυσκολίας υλοποίησης αλλά και των ιδιαιτεροτήτων της τεχνολογίας του Midnight, αναγκαστήκαμε να προβούμε σε μερικές παραδοχές για τη λειτοργία - χρήση της εφαρμογής.
\begin{itemize}
    \item Όλοι οι φοιτητές μπορούν να συμμετέχουν σε όλες τις διαθέσιμες ψηφοφορίες.
    \item Υπάρχει ένα smart contract πάνω στο οποίο έχει χτιστεί η εφαρμογή και όπως έχουμε περιγράψει, οι έγκυροι χρήστες καθορίζονται πριν την δημιουργία του smart contract. Συνεπώς, με την ένταξη νέων φοιτητών στο πανεπιστήμιο, θα πρέπει να δημιουργείται πάλι το smart contract από το πανεπιστήμιο ώστε να συμπεριληφθούν και οι νεοεισαχθέντες φοιτητές.
    \item Αφού ψηφίσει ένας φοιτητές και αφού ο organizer κλείσει μια ψηφοφορία, θεωρούμε ότι ο φοιτητής θα πρέπει να δημοσιεύσει την ψήφο του αμέσως, διαφορετικά αυτή δε θα μετρήσει.
    \item  Αν κάποιος φοιτητής χάσει το secret key του, δεν υπάρχει μηχανισμός ανάκτησης ή χορήγησης κάποιου νέου κλειδιού.
\end{itemize}

\section{Μελλοντικές Κατευθύνσεις - Βελτιώσεις}
Λόγω των παραδοχών που αναφέρθηκαν προηγουμένως, προτείνουμε λύσεις και επεκτάσεις οι οποίες θα έκανα την εφαρμογή πιο ρεαλιστική και θα της προσέφεραν περισσότερες δυνατότητες.
\begin{itemize}
    \item Για να υπάρχει μεγαλύτερη ευελιξία, μπορούν οι φοιτητές να λαμβάνουν πέρα από ένα απλό secret key, ένα πιστοποιητικό πως ανήκουν σε κάποιο συγκεκριμένο εξάμηνο ή σε κάποια φοιτητική ομάδα. Με αυτό τον τρόπο, μπορεί να δημιουργούνται ψηφοφορίες μόνο για συγκεκριμένες φοιτητικές ομάδες ή για συγκεκριμένα εξάμηνα.
    \item Μπορούν να επεκταθούν οι κανόνες του smart contract ώστε να οριστεί κάποιο deadline στις ψηφοφορίες και να μη μπορεί ο χρήστης να δημοσιεύσει την ψήφο του μετά του πέρας αυτού του deadline. 
    \item Επειδή ακριβώς οι έγκυροι χρήστες καθορίζονται πριν την δημιουργία του smart contract και δεν υπάρχει ευελιξία αν πρέπει να προστεθεί κάποιος νέος χρήστης ή αν κάποιος χρήστης χάσει το secret key του είναι κάθε ψηφορορία να αποτελεί ένα ξεχωριστό smart contract και ο κάθε χρήστης να μπορεί να αυθεντικοποεί τον εαυτό του για αυτή την ψηφοφορία. Δοκιμάσαμε μια τέτοια υλοποίηση, όπου ο κάθε χρήστης όταν δημιουργεί μια ψηφοφορία, ουσιαστικά δημοσιεύει ένα νέο contract, και υπάρχει ένα transaction add\_voter το οποίο προσθέτει ένα public key στο merkle tree με τους έγκυρους ψηφοφόρους. Ωστόσο, εγκαταλείψαμε αυτή τη λύσει, διότι το add\_voter πραγματοποιούταν από το πανεπιστήμιο, κάτι το οποίο του έδινε περισσότερη ισχύ και ένα malicious πανεπιστήμιο θα μπορούσε να προσθέτει όσους και όποιους χρήστες θέλει, παραβιάζοντας τη διαφάνεια των ψηφοφοριών. Παρ'όλα αυτά μπορούν να εξερευνηθούν μέθοδοι που θα επέτρεπαν μια τέτοια πιο ευέλικτη υλοποίηση και ταυτόχρονα δε θα ενίσχυαν τόσο πολύ τη δύναμη της κεντρικής αρχής. 
\end{itemize}   

\printbibliography


\end{document}
