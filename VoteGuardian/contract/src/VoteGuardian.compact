include "std";
import "../../crypto/Crypto";
export { Maybe }

// Voting states: voting can be open, or counted
export enum VOTE_STATE { open, closed }

// Public key of the voting organizer
export ledger voting_organizer: Bytes<32>;

// Ledger to store the state of voting (open, or closed)
export ledger vote_state: VOTE_STATE;

// Unique one-time "tokens" for someone to vote
export ledger voting_nulifiers: Set<Bytes<32>>;

// Ledger to store votes in encrypted formd
export ledger votes_list: List<Opaque<"string">>;

// Counter for total votes, incremented with each vote cast
export ledger vote_count: Counter;

// List with the questions of the voting. At first it will be only one question
export ledger vote_question: Opaque<"string">;

// Ledger to store options and their id. For example: 1: "yes", 2: "no"
export ledger vote_option_map: Map<Opaque<"string">, Opaque<"string">>;


// Constructor initializes the state
constructor() {
    voting_organizer = public_key(local_secret_key());
    vote_state = VOTE_STATE.open;
    vote_count.increment(0); // Initialize vote count at zero
    voting_nulifiers.reset_to_default();
}

// Witness function to hold the user's (voter or organizer) secret key
witness local_signed_credential(): SignedCredentialSubject;


// Function to cast a vote, only accessible when voting is open and the voter hasn’t already voted
export circuit cast_vote(vote_option: Opaque<"string">): [] {
    // assert voting_organizer != public_key(local_secret_key())
    //     "As organizer, you are not allowed to vote!";

    assert vote_state == VOTE_STATE.open
        "Voting is not open";

    const signed_credential = local_signed_credential();

    // Ελέγχεται αν υπογραφή που λαμβάνει ο χρήστης για τα στοιχεία που έχει δώσει είναι έγκυρη
    verify_signature(subject_hash(signed_credential.subject), signed_credential.signature);

    //  // Υπολόγισε το nullifier για τον τρέχον χρήστη χασάρωντας το secret key του.
    // const voting_nullifier = nullifier(local_secret_key());

    // // Έλεγχος αν ο nullifier για τον τρέχον χρήστη ανήκει στο σύνολο. Αν ανήκει σημαίνει ότι έχει ήδη ψηφίσει
    // assert !voting_nulifiers.member(voting_nullifier) 
    //     "You have already voted!";

    // voting_nulifiers.insert(voting_nullifier);

    assert vote_option_map.member(vote_option)
        "Not a valid option!";

    // Record the vote 
    const vote = vote_option_map.lookup(vote_option);

    votes_list.push_front(vote);
    vote_count.increment(1);
}

// Function to close the voting phase
export circuit close_voting(): [] {
    // assert voting_organizer == public_key(local_secret_key())
    //     "You are not authorized to close the voting";

    assert vote_state == VOTE_STATE.open
        "Voting phase is not open or has already closed";
    vote_state = VOTE_STATE.closed;
}

export circuit create_voting(vq: Opaque<"string">): [] {
    // assert voting_organizer == public_key(local_secret_key())
    //     "You are not authorized to start a voting";
    vote_question = vq;
}

export circuit add_option(vote_option: Opaque<"string">, i: Opaque<"string">): [] {
    // assert voting_organizer == public_key(local_secret_key())
    //     "You are not authorized to add a voting option!";

    vote_option_map.insert(i, vote_option);
}

export circuit verify_identity(msg: Bytes<32>, signature: Signature): [] {
  verify_signature(msg, signature);
}

// Function to compute a public key for a voter based on secret key
export circuit public_key(sk: Bytes<32>): Bytes<32> {
    return persistent_hash<Bytes<32>>(sk);
}

circuit nullifier(sk: Bytes<32>): Bytes<32> {
  return persistent_hash<Vector<2, Bytes<32>>>([pad(32, "nullifier-domain"), sk]);
}

// Utility function to decrypt a vote (assumes encrypted vote format)
// fn decrypt(encrypted_vote: Opaque<"string">): Opaque<"string"> {
//     // Actual decryption logic here (for simplicity, left as a placeholder)
//     return encrypted_vote;
// }