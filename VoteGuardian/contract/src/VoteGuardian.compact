import CompactStandardLibrary;

// Voting states: voting can be open, or counted
export enum VOTE_STATE { open, closed }

export ledger count: Counter;

// Public key of the university
export ledger university_public_key: Bytes<32>;

export ledger votings: Map<Bytes<32>, Opaque<"string">>;                // Map with the votings ids and the question of each voting
export ledger voting_options: Map<Bytes<32>, Map<Opaque<"string">, Opaque<"string">>>; // Map with the options of each question of each voting;
export ledger votes_list: Map<Bytes<32>, List<Opaque<"string">>>;        // Map with a list of votes for each voting
export ledger eligible_voters: HistoricMerkleTree<5, Bytes<32>>;      // Merkle tree of eligible voters
export ledger voting_states: Map<Bytes<32>, VOTE_STATE>;                // Map with the state of each voting
export ledger voting_nulifiers: Map<Bytes<32>, Set<Bytes<32>>>;         // Unique tokens per voting per user to avoid double voting
export ledger voting_organizers: Map<Bytes<32>, Set<Bytes<32>>>;        // Map with the votings of each organizer

// Constructor initializes the ADTs and predefines eligible voters
constructor(eligible_voter_public_keys: Vector<5, Bytes<32>>) {
    university_public_key = disclose(public_key(local_secret_key()));
    voting_options.resetToDefault(); 
    votes_list.resetToDefault();
    voting_states.resetToDefault();
    voting_nulifiers.resetToDefault();
    voting_organizers.resetToDefault();

    for (const v of disclose(eligible_voter_public_keys)) {
        eligible_voters.insert(v);
    }
}

// Witness function to hold the user's (voter or organizer) secret key
witness local_secret_key(): Bytes<32>;

// Witness that prooves if a public_key is inside the Merkle Tree
witness find_voter_public_key(voter_public_key: Bytes<32>): MerkleTreePath<5, Bytes<32>>;

circuit prove_eligibility(): Boolean {
    const participant_public_key = disclose(public_key(local_secret_key()));
    const path = find_voter_public_key(participant_public_key);

    if (eligible_voters.checkRoot(merkleTreePathRoot<5, Bytes<32>>(path)))
        return true;
    else 
        return false;
        
}

circuit voting_belongs_to_organizer(voting_id: Bytes<32>, organizer_public_key: Bytes<32>): Boolean {
    const organizer_votings_set = voting_organizers.lookup(organizer_public_key);
    if (organizer_votings_set.member(voting_id)) {
        return true;
    }
    else {
        return false;
    }
}


export circuit create_voting(voting_question: Opaque<"string">): [] {
    const organizer_public_key = disclose(public_key(local_secret_key()));

    assert (university_public_key == organizer_public_key,
        "University cannot create votings");

    assert (prove_eligibility(), 
        "Not authorized!");

    const voting_id = disclose(generate_voting_id(local_secret_key()));

    voting_organizers.insert(organizer_public_key, voting_id);
    votings.insert(voting_id, voting_question);
    count.increment(1);
}

export circuit add_option(voting_id: Bytes<32>, vote_option: Opaque<"string">, i: Opaque<"string">): [] {
    const organizer_public_key = disclose(public_key(local_secret_key()));
    
    assert (prove_eligibility(),
        "Not authorized");

    assert (voting_belongs_to_organizer(voting_id, organizer_public_key),
        "Not authorized");   

    voting_options.insert(organizer_public_key, (i, vote_option));
}


export circuit close_voting(voting_id: Bytes<32>): [] {
    const organizer_public_key = disclose(public_key(local_secret_key()));

    assert (prove_eligibility(),
        "Not authorized");   

    assert (voting_belongs_to_organizer(voting_id, organizer_public_key),
        "Not authorized");       

    const current_voting_state = voting_states.lookup(organizer_public_key);

    assert (current_voting_state == VOTE_STATE.open,
        "Voting phase is not open or has already closed");
    
    voting_states.insert(organizer_public_key, VOTE_STATE.closed);
}

export circuit open_voting(voting_id: Bytes<32>): [] {
    const organizer_public_key = disclose(public_key(local_secret_key()));

    assert (prove_eligibility(),
        "Not authorized");    

    assert (voting_belongs_to_organizer(voting_id, organizer_public_key),
        "Not authorized");        

    const current_voting_state = voting_states.lookup(organizer_public_key);

    assert (current_voting_state == VOTE_STATE.closed,
        "Voting phase is not closed or has already opened");
    
    voting_states.insert(organizer_public_key, VOTE_STATE.open);
}


// Function to cast a vote, only accessible when voting is open and the voter hasn’t already voted
export circuit cast_vote(voting_id: Bytes<32>, vote_option: Opaque<"string">): [] {
    const organizer_public_key = disclose(public_key(local_secret_key()));

    const current_voting_state = voting_states.lookup(voting_id);

    assert (current_voting_state == VOTE_STATE.open, 
        "Voting is not open");

    const voter_public_key = disclose(public_key(local_secret_key()));

    assert (prove_eligibility(), 
        "Not authorized!");

    const voting_nulifiers_set = voting_nulifiers.lookup(voting_id);

    const voting_nullifier = disclose(nullifier(local_secret_key()));

    // Έλεγχος αν ο nullifier για τον τρέχον χρήστη ανήκει στο σύνολο. Αν ανήκει σημαίνει ότι έχει ήδη ψηφίσει
    assert (!voting_nulifiers_set.member(voting_nullifier),
        "Already voted for this voting");

    voting_nulifiers.insert(voting_id, (voting_nullifier));

    // Record the vote and the nullifiers
    voting_nulifiers.remove(voting_id);
    voting_nulifiers_set.insert(voting_nullifier);
    voting_nulifiers.insert(voting_id, voting_nulifiers_set);

    const current_vote_option_map = voting_options.lookup(voting_id);

    assert (current_vote_option_map.member(vote_option),
        "Not a valid option!");

    const vote = current_vote_option_map.lookup(vote_option);

    const current_vote_list = votes_list.lookup(voting_id);
    votes_list.remove(voting_id);
    current_vote_list.push_front(vote); // must run the contract again
    votes_list.insert(current_vote_list);
}


// Function to compute a public key for a voter based on secret key
circuit public_key(sk: Bytes<32>): Bytes<32> {
    return persistentHash<Bytes<32>>(sk);
}

circuit nullifier (sk: Bytes<32>): Bytes<32> {
  return persistentHash<Vector<2, Bytes<32>>>([pad(32, "nullifier-domain"), sk]);
}

circuit generate_voting_id (sk: Bytes<32>) : Bytes<32> {
    return persistentHash<Vector<3, Bytes<32>>>(
           [pad(32, "generate_id"), count as Bytes<32>, sk]);
}
