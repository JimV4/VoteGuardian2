include "std";
export { Maybe }

// Voting states: voting can be open, or counted
export enum VOTE_STATE { open, closed }

// Public key of the voting organizer
export ledger voting_organizer: Cell<Bytes<32>>;

// Ledger to store the state of voting (open, or closed)
export ledger vote_state: Cell<VOTE_STATE>;

// Unique one-time "tokens" for someone to vote
export ledger voting_nulifiers: Set<Bytes<32>>;

// Ledger to store votes in encrypted formd
export ledger votes_list: List<Opaque<"string">>;

// Counter for total votes, incremented with each vote cast
export ledger vote_count: Counter;

// List with the questions of the voting. At first it will be only one question
export ledger vote_question: Cell<Opaque<"string">>;

// Ledger to store options and their id. For example: 1: "yes", 2: "no"
export ledger vote_option_map: Map<Opaque<"string">, Opaque<"string">>;


// Constructor initializes the state
constructor() {
    voting_organizer = public_key(local_secret_key());
    vote_state = VOTE_STATE.open;
    vote_count.increment(0); // Initialize vote count at zero
    voting_nulifiers.reset_to_default();
}

// Witness function to hold the user's (voter or organizer) secret key
witness local_secret_key(): SignedCredentialSubject;


// Function to cast a vote, only accessible when voting is open and the voter hasn’t already voted
export circuit cast_vote(vote_option: Opaque<"string">): Void {
    assert voting_organizer != public_key(local_secret_key())
        "As organizer, you are not allowed to vote!";

    assert vote_state == VOTE_STATE.open
        "Voting is not open";

    const voter_public_key = public_key(local_secret_key());

    const signed_credential = local_secret_key();

    // Ελέγχεται αν υπογραφή που λαμβάνει ο χρήστης για τα στοιχεία που έχει δώσει είναι έγκυρη
    verify_signature(subject_hash(signed_credential.subject), signed_credential.signature);

    //  // Υπολόγισε το nullifier για τον τρέχον χρήστη χασάρωντας το secret key του.
    // const voting_nullifier = nullifier(local_secret_key());

    // // Έλεγχος αν ο nullifier για τον τρέχον χρήστη ανήκει στο σύνολο. Αν ανήκει σημαίνει ότι έχει ήδη ψηφίσει
    // assert !voting_nulifiers.member(voting_nullifier) 
    //     "You have already voted!";

    // voting_nulifiers.insert(voting_nullifier);

    assert vote_option_map.member(vote_option)
        "Not a valid option!";

    // Record the vote 
    const vote = vote_option_map.lookup(vote_option);

    votes_list.push_front(vote);
    vote_count.increment(1);
}

// Function to close the voting phase
export circuit close_voting(): Void {
    assert voting_organizer == public_key(local_secret_key())
        "You are not authorized to close the voting";

    assert vote_state == VOTE_STATE.open
        "Voting phase is not open or has already closed";
    vote_state = VOTE_STATE.closed;
}

export circuit create_voting(vq: Opaque<"string">): Void {
    assert voting_organizer == public_key(local_secret_key())
        "You are not authorized to start a voting";
    vote_question = vq;
}

export circuit add_option(vote_option: Opaque<"string">, i: Opaque<"string">): Void {
    assert voting_organizer == public_key(local_secret_key())
        "You are not authorized to add a voting option!";

    vote_option_map.insert(i, vote_option);
}


// Function to compute a public key for a voter based on secret key
export circuit public_key(sk: Bytes<32>): Bytes<32> {
    return persistent_hash<Bytes<32>>(sk);
}

circuit nullifier(sk: Bytes<32>): Bytes<32> {
  return persistent_hash<Vector<2, Bytes<32>>>([pad(32, "nullifier-domain"), sk]);
}

// Utility function to decrypt a vote (assumes encrypted vote format)
// fn decrypt(encrypted_vote: Opaque<"string">): Opaque<"string"> {
//     // Actual decryption logic here (for simplicity, left as a placeholder)
//     return encrypted_vote;
// }

////////////////////////////////////SIGNATURE SIGN AND VERIFICATION///////////////////////////////////////////////
circuit point_to_bytes(p: CurvePoint): Bytes<32> {
    return persistent_hash<CurvePoint>(p);
  }

  struct Bytes96 {
    b0: Bytes<32>;
    b1: Bytes<32>;
    b2: Bytes<32>;
  }

  struct Bytes64 {
    b0: Bytes<32>;
    b1: Bytes<32>;
  }

  export struct Signature {
    pk: CurvePoint;
    R: CurvePoint;
    s: Field;
  }

  // Could be used as a credential subject as defined in https://w3c-ccg.github.io/vc-data-model/#credential-subject
  // We need a standard for a canonical representation of a credential subject, so we can hash it consistently
  export struct CredentialSubject {
      id: Bytes<32>; // The id of the subject (midnight wallet own_public_key)
      first_name: Bytes<32>; // The first name of the subject
      last_name: Bytes<32>; // The last name of the subject
      hashed_password: Bytes<32>; // The birth timestamp of the subject
  }

  export struct SignedCredentialSubject {
    subject: CredentialSubject;
    signature: Signature;
  }

  export pure circuit subject_hash(credentialSubject: CredentialSubject): Bytes<32> {
    return persistent_hash<CredentialSubject>(credentialSubject);
  }

  export pure circuit derive_pk(sk_bytes: Bytes<32>): CurvePoint {
     const sk: Field = 0; //transient_hash<Bytes<32>>(sk_bytes);
     const pk: CurvePoint = ec_mul_generator(sk);
     return pk;
  }

  export pure circuit sign(msg: Bytes<32>, sk_bytes: Bytes<32>): Signature {
    // Convert sk_bytes to Field
    const sk: Field = transient_hash<Bytes<32>>(sk_bytes);
    // Compute public key: pk = g^sk
    const pk: CurvePoint = ec_mul_generator(sk);

    // Derive nonce k deterministically: k = H(sk_bytes || msg)
    const nonce_input: Bytes64 = Bytes64 { b0: sk_bytes, b1: msg };
    const k: Field = transient_hash<Bytes64>(nonce_input); // Hash to scalar

    // Compute r = g^k
    const r: CurvePoint = ec_mul_generator(k);

    // Compute challenge: e = H(r || msg)
    const r_bytes: Bytes<32> = point_to_bytes(r);
    const pk_bytes: Bytes<32> = point_to_bytes(pk);
    const e_bytes: Bytes96 = Bytes96 {
      b0: r_bytes,
      b1: pk_bytes,
      b2: msg
    };
    const e: Field = transient_hash<Bytes96>(c_bytes);

    // Compute signature: s = k + sk * e
    const s: Field = k + (sk * e);

    return Signature { pk: pk, R: R, s: s };
  }

  export pure circuit verify_signature(msg: Bytes<32>, signature: Signature): [] {
    const {pk, R, s} = signature;
    // Compute challenge: c = H(R || pk || msg)
    const R_bytes: Bytes<32> = point_to_bytes(R);
    const pk_bytes: Bytes<32> = point_to_bytes(pk);
    const c_bytes: Bytes96 = Bytes96 {
      b0: R_bytes,
      b1: pk_bytes,
      b2: msg
    };
    const c: Field = transient_hash<Bytes96>(c_bytes);

    // Left-hand side: s * B
    const lhs: CurvePoint = ec_mul_generator(s);

    // Right-hand side: R + c * pk
    const c_pk: CurvePoint = ec_mul(pk, c);
    const rhs: CurvePoint = ec_add(R, c_pk);

    // Enforce verification equation
    assert lhs == rhs "Signature verification failed";
  }