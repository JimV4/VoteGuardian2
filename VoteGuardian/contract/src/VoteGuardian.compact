include "std";
export { Maybe }

// Voting states: voting can be open, or counted
export enum VOTE_STATE { open, closed }

// Public key of the voting organizer
export ledger voting_organizer: Cell<Bytes<32>>;

// Ledger to store the state of voting (open, or closed)
export ledger vote_state: Cell<VOTE_STATE>;

// Ledger to store eligible voters in Merkle Tree
export ledger eligible_voters: HistoricMerkleTree<10, Bytes<32>>;

// Unique one-time "tokens" for someone to vote
export ledger voting_nulifiers: Set<Bytes<32>>;

// Ledger to store votes in encrypted formd
export ledger votes_list: List<Opaque<"string">>;

// Counter for total votes, incremented with each vote cast
export ledger vote_count: Counter;

// List with the questions of the voting. At first it will be only one question
export ledger vote_question: Cell<Opaque<"string">>;

// Ledger to store options and their id. For example: 1: "yes", 2: "no"
// export ledger vote_option_map: Map<Opaque<"string">, Opaque<"string">>;


// Constructor initializes the state
constructor() {
    voting_organizer = public_key(local_secret_key());
    vote_state = VOTE_STATE.open;
    vote_count.increment(0); // Initialize vote count at zero
    eligible_voters.reset_to_default(); // Set eligible voters as the empty Merkle Tree
    voting_nulifiers.reset_to_default();
}

// Witness function to hold the user's (voter or organizer) secret key
witness local_secret_key(): Bytes<32>;

// Witness that prooves if a public_key is inside the Merkle Tree
witness find_voter_public_key(voter_public_key: Bytes<32>): MerkleTreePath<10, Bytes<32>>;


export circuit add_voter(voter_public_key: Bytes<32>): Void {
    assert voting_organizer == public_key(local_secret_key())
        "You are not authorized to add a voter!";

    assert voter_public_key != public_key(local_secret_key())
        "You cannot add yourself to the voting!";

    // insert the voter into eligible voters Merkle Tree
    eligible_voters.insert(voter_public_key);
}


// Function to cast a vote, only accessible when voting is open and the voter hasn’t already voted
export circuit cast_vote(vote_option: Opaque<"string">): Void {
    assert voting_organizer != public_key(local_secret_key())
        "As organizer, you are not allowed to vote!";

    assert vote_state == VOTE_STATE.open
        "Voting is not open";

    const voter_public_key = public_key(local_secret_key());

    // voter must be in the eligible voters
    const path = find_voter_public_key(voter_public_key);

    assert eligible_voters.check_root(merkle_tree_path_root<10, Bytes<32>>(path)) 
        "You are not authorized to vote!";

     // Υπολόγισε το nullifier για τον τρέχον χρήστη χασάρωντας το secret key του.
    const voting_nullifier = nullifier(local_secret_key());

    // Έλεγχος αν ο nullifier για τον τρέχον χρήστη ανήκει στο σύνολο. Αν ανήκει σημαίνει ότι έχει ήδη ψηφίσει
    assert !voting_nulifiers.member(voting_nullifier) 
        "You have already voted!";

    voting_nulifiers.insert(voting_nullifier);

    // assert vote_option_map.member(vote_option)
    //     "Not a valid option!";

    // Record the vote 
    // const vote = vote_option_map.lookup(vote_option);

    votes_list.push_front(vote_option);
    vote_count.increment(1);
}

// Function to close the voting phase
export circuit close_voting(): Void {
    assert voting_organizer == public_key(local_secret_key())
        "You are not authorized to close the voting";

    assert vote_state == VOTE_STATE.open
        "Voting phase is not open or has already closed";
    vote_state = VOTE_STATE.closed;
}

export circuit create_voting(vq: Opaque<"string">): Void {
    assert voting_organizer == public_key(local_secret_key())
        "You are not authorized to start a voting";
    vote_question = vq;
}

export circuit add_option(vote_option: Opaque<"string">, i: Opaque<"string">): Void {
    assert voting_organizer == public_key(local_secret_key())
        "You are not authorized to add a voting option!";

    // vote_option_map.insert(i, vote_option);
}


// Function to compute a public key for a voter based on secret key
export circuit public_key(sk: Bytes<32>): Bytes<32> {
    return persistent_hash<Bytes<32>>(sk);
}

circuit nullifier(sk: Bytes<32>): Bytes<32> {
  return persistent_hash<Vector<2, Bytes<32>>>([pad(32, "nullifier-domain"), sk]);
}

// Utility function to decrypt a vote (assumes encrypted vote format)
// fn decrypt(encrypted_vote: Opaque<"string">): Opaque<"string"> {
//     // Actual decryption logic here (for simplicity, left as a placeholder)
//     return encrypted_vote;
// }