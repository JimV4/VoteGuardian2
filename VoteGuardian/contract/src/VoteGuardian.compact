include "std";
export { Maybe }

// Voting states: voting can be open, or counted
export enum VOTE_STATE { open, closed }

export ledger count: Counter;

// Public key of the university
export ledger university_public_key: Bytes<32>;

// Ledger to store the state of voting (open, or closed)
export ledger votings: Map<Bytes<32>, Opaque<"string">>;                // Map with the votings ids and the question of each voting
export ledger voting_options: Map<Bytes<32>, Map<Opaque<"string">, Opaque<"string">>; // Map with the options of each question of each voting;
export ledger votes_list: Map<Bytes<32>, List<Opaque<"string">>;        // Map with a list of votes for each voting
export ledger eligible_voters: HistoricMerkleTree<100, Bytes<32>>;      // Merkle tree of eligible voters
export ledger voting_states: Map<Bytes<32>, VOTE_STATE>;                // Map with the state of each voting
export ledger voting_nulifiers: Map<Bytes<32>, Set<Bytes<32>>>;         // Unique tokens per voting per user to avoid double voting
export ledger voting_organizers: Map<Bytes<32>, Bytes<32>>;             // Map with the votings of each organizer

// Constructor initializes the ADTs and predefines eligible voters
constructor() {
    university_public_key = disclose(public_key(local_secret_key()));
    voting_options.reset_to_default(); 
    votes_list.reset_to_default();
    eligible_voters.reset_to_default();
    voting_states.reset_to_default();
    voting_nulifiers.reset_to_default();
    voting_organizers.reset_to_default();
}

// Witness function to hold the user's (voter or organizer) secret key
witness local_secret_key(): Bytes<32>;

// Witness that prooves if a public_key is inside the Merkle Tree
witness find_voter_public_key(voter_public_key: Bytes<32>): MerkleTreePath<10, Bytes<32>>;

circuit prove_eligibility(): Boolean {
    const participant_public_key = disclose(public_key(local_secret_key()));
    const path = participant_public_key;

    if (eligible_voters.check_root(merkle_tree_path_root<10, Bytes<32>>(path)))
        return true;
    else 
        return false;
        
}


export circuit create_voting(voting_question: Opaque<"string">): [] {
    const organizer_public_key = disclose(public_key(local_secret_key()));

    assert university_public_key == organizer_public_key
        "University cannot create votings";

    assert prove_eligibility
        "Not authorized!"

    votings.insert(organizer_public_key, voting_question);
}

export circuit add_option(vote_option: Opaque<"string">, i: Opaque<"string">): [] {
     const organizer_public_key = disclose(public_key(local_secret_key()));

    assert university_public_key == organizer_public_key
        "University cannot add options";

    assert prove_eligibility
        "Not authorized!"    

    voting_options.insert(organizer_public_key, (i, vote_option));
}


export circuit close_voting(): [] {
    const organizer_public_key = disclose(public_key(local_secret_key()));

    assert university_public_key == public_key(local_secret_key())
        "University cannot close votings";

    const current_voting_state = voting_states.lookup(university_public_key);

    assert current_voting_state == VOTE_STATE.open
        "Voting phase is not open or has already closed";
    
    voting_states.insert(organizer_public_key, VOTE_STATE.closed);
}

export circuit open_voting(): [] {
    const organizer_public_key = disclose(public_key(local_secret_key()));

    assert university_public_key == public_key(local_secret_key())
        "University cannot open votings";

    const current_voting_state = voting_states.lookup(organizer_public_key);

    assert current_voting_state == VOTE_STATE.closed
        "Voting phase is not closed or has already opened";
    
    voting_states.insert(organizer_public_key, VOTE_STATE.open);
}


// Function to cast a vote, only accessible when voting is open and the voter hasn’t already voted
export circuit cast_vote(voting_id: Bytes<32>, vote_option: Opaque<"string">): [] {
    const organizer_public_key = disclose(public_key(local_secret_key()));

    assert university_public_key == public_key(local_secret_key())
        "University cannot open votings";


    const current_voting_state = voting_states.lookup(voting_id);

    assert current_voting_state == VOTE_STATE.open
        "Voting is not open";

    const voter_public_key = disclose(public_key(local_secret_key()));

    assert prove_eligibility
        "Not authorized!"

    const voting_nulifiers_set = voting_nulifiers.lookup(voting_id)

    const voting_nullifier = disclose(nullifier(local_secret_key()));

    // Έλεγχος αν ο nullifier για τον τρέχον χρήστη ανήκει στο σύνολο. Αν ανήκει σημαίνει ότι έχει ήδη ψηφίσει
    assert !voting_nulifiers_set.member(voting_nullifier) 
        "Already voted for this voting";

    voting_nulifiers.insert(voting_id, (voting_nullifier));

    assert vote_option_map.member(vote_option)
        "Not a valid option!";

    // Record the vote and the nullifiers
    voting_nulifiers.remove(voting_id);
    voting_nulifiers_set.insert(voting_nullifier);
    voting_nulifiers.insert(voting_id, voting_nulifiers_set);

    const current_vote_option_map = voting_options.lookup(voting_id);
    const vote = current_vote_option_map.lookup(vote_option);

    const current_vote_list = votes_list.lookup(voting_id);
    votes_list.remove(voting_id);
    current_vote_list.push_front(vote); // must run the contract again
    votes_list.insert(current_vote_list);
}

// Function to close the voting phase
export circuit close_voting(): [] {
    assert voting_organizer == public_key(local_secret_key())
        "You are not authorized to close the voting";

    assert vote_state == VOTE_STATE.open
        "Voting phase is not open or has already closed";
    vote_state = VOTE_STATE.closed;
}

// Function to open the voting phase
export circuit open_voting(): [] {
    assert voting_organizer == public_key(local_secret_key())
        "You are not authorized to open the voting";

    assert vote_state == VOTE_STATE.closed
        "Voting phase is not closed or has already opened";
    vote_state = VOTE_STATE.open;
}

export circuit add_option(vote_option: Opaque<"string">, i: Opaque<"string">): [] {
    assert voting_organizer == public_key(local_secret_key())
        "You are not authorized to add a voting option!";

    vote_option_map.insert(i, vote_option);
}


// Function to compute a public key for a voter based on secret key
export circuit public_key(sk: Bytes<32>): Bytes<32> {
    return persistent_hash<Bytes<32>>(sk);
}

circuit nullifier (sk: Bytes<32>): Bytes<32> {
  return persistent_hash<Vector<2, Bytes<32>>>([pad(32, "nullifier-domain"), sk]);
}

circuit generate_voting_id (pk: Bytes<32>) : Bytes<32> {
    return persistentHash<Vector<3, Bytes<32>>>(
           [pad(32, "generate_id"), round as Bytes<32>, pk]);
}
