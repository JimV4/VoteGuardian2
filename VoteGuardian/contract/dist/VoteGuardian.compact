import CompactStandardLibrary;

// Voting states: voting can be open, or counted
export enum VOTE_STATE { open, closed }

export ledger count: Counter;

// Public key of the university
export ledger university_public_key: Bytes<32>;

export ledger votings: Set<Bytes<32>>;                // Map with the votings ids and the question of each voting
export ledger voting_options: Map<Bytes<32>, Set<Bytes<32>>>; 
export ledger voting_questions: Map<Bytes<32>, Opaque<"string">>;
export ledger voting_results: Map<Bytes<32>, Map<Bytes<32>, Counter>>;        // Map with a list of votes for each voting
export ledger eligible_voters: HistoricMerkleTree<5, Bytes<32>>;      // Merkle tree of eligible voters
export ledger voting_states: Map<Bytes<32>, VOTE_STATE>;                // Map with the state of each voting
export ledger voting_nulifiers: Map<Bytes<32>, Set<Bytes<32>>>;         // Unique tokens per voting per user to avoid double voting
export ledger publish_voting_nulifiers: Map<Bytes<32>, Set<Bytes<32>>>;         // Unique tokens per voting per user to avoid double vote publishing
export ledger voting_organizers: Map<Bytes<32>, Bytes<32>>;        // Map with the votings of each organizer
export ledger hashed_votes: Map<Bytes<32>, Set<Bytes<32>>>;
export ledger publish_vote_expiration_time: Map<Bytes<32>, Uint<64>>;
export ledger cast_vote_expiration_time: Map<Bytes<32>, Uint<64>>;

// Constructor initializes the ADTs and predefines eligible voters
constructor(eligible_voter_public_keys: Vector<5, Bytes<32>>) {
    university_public_key = disclose(public_key(local_secret_key()));
    votings.resetToDefault();
    voting_options.resetToDefault(); 
    voting_results.resetToDefault();
    voting_states.resetToDefault();
    voting_nulifiers.resetToDefault();
    voting_organizers.resetToDefault();
    voting_questions.resetToDefault();
    hashed_votes.resetToDefault();
    publish_voting_nulifiers.resetToDefault();
    publish_vote_expiration_time.resetToDefault();
    cast_vote_expiration_time.resetToDefault();
    count.increment(1);

    for (const v of disclose(eligible_voter_public_keys)) {
        eligible_voters.insert(v);
    }
}

// Witness function to hold the user's (voter or organizer) secret key
witness local_secret_key(): Bytes<32>;

// Witness that prooves if a public_key is inside the Merkle Tree
witness find_voter_public_key(voter_public_key: Bytes<32>): MerkleTreePath<5, Bytes<32>>;

// Witness that holds the user's actual vote for a voting
witness secret_vote(voting_id: Bytes<32>): Bytes<32>; 

circuit prove_eligibility(): Boolean {
    const participant_public_key = public_key(local_secret_key());
    const path = find_voter_public_key(participant_public_key);

    return eligible_voters.checkRoot(disclose(merkleTreePathRoot<5, Bytes<32>>(path)));
        
}

circuit voting_belongs_to_organizer(voting_id: Bytes<32>, organizer_public_key: Bytes<32>): Boolean {
    if (voting_organizers.lookup(voting_id) == organizer_public_key) {
        return true;
    }
    else {
        return false;
    }
}


export circuit create_voting(publish_vote_expiration_time_v: Uint<64>, cast_vote_expiration_time_v: Uint<64>): [] {
    const organizer_public_key = disclose(public_key(local_secret_key()));

    assert (publish_vote_expiration_time_v > cast_vote_expiration_time_v,
        "Publish vote deadline must be after cast vote deadline");

    assert (university_public_key != organizer_public_key,
        "University cannot create votings");

    assert (prove_eligibility(), 
        "Not authorized!");

    const voting_id = generate_voting_id(count, local_secret_key());

    voting_organizers.insert(disclose(voting_id), organizer_public_key);
    votings.insert(disclose(voting_id));
    voting_states.insert(disclose(voting_id), VOTE_STATE.closed);
    voting_options.insert(disclose(voting_id), default<Set<Bytes<32>>>);
    voting_nulifiers.insert(disclose(voting_id), default<Set<Bytes<32>>>);
    publish_voting_nulifiers.insert(disclose(voting_id), default<Set<Bytes<32>>>);
    hashed_votes.insert(disclose(voting_id), default<Set<Bytes<32>>>);
    voting_results.insert(disclose(voting_id), default<Map<Bytes<32>, Counter>>);
    publish_vote_expiration_time.insert(disclose(voting_id), disclose(publish_vote_expiration_time_v));
    cast_vote_expiration_time.insert(disclose(voting_id), disclose(cast_vote_expiration_time_v));
    count.increment(1);
}

export circuit edit_question(voting_id: Bytes<32>, voting_question: Opaque<"string">): [] {
    const organizer_public_key = disclose(public_key(local_secret_key()));
    
    assert (prove_eligibility(),
        "Not authorized");

    assert (voting_organizers.lookup(disclose(voting_id)) == organizer_public_key,
        "Not authorized");   

    const current_voting_state = voting_states.lookup(disclose(voting_id));

    assert (current_voting_state == VOTE_STATE.closed,
        "Cannot edit the question since the voting is open");    

    voting_questions.insert(disclose(voting_id), disclose(voting_question));
}

export circuit add_option(voting_id: Bytes<32>, vote_option: Bytes<32>): [] {
    const organizer_public_key = public_key(local_secret_key());
    
    assert (prove_eligibility(),
        "Not authorized");

    assert (voting_organizers.lookup(disclose(voting_id)) == organizer_public_key,
        "Not authorized");   

    const current_voting_state = voting_states.lookup(disclose(voting_id));

    assert (current_voting_state == VOTE_STATE.closed,
        "Cannot add option since the voting is open");    

    voting_options.lookup(disclose(voting_id)).insert(disclose(vote_option));
    voting_results.lookup(disclose(voting_id)).insert(disclose(vote_option), default<Counter>);

}


// export circuit close_voting(voting_id: Bytes<32>): [] {
//     const organizer_public_key = public_key(local_secret_key());

//     assert (prove_eligibility(),
//         "Not authorized");   

//     assert (voting_organizers.lookup(disclose(voting_id)) == organizer_public_key,
//         "Not authorized");       

//     const current_voting_state = voting_states.lookup(disclose(voting_id));

//     assert (current_voting_state == VOTE_STATE.open,
//         "Voting phase is not open or has already closed");
    
//     voting_states.insert(disclose(voting_id), VOTE_STATE.closed);
// }

export circuit open_voting(voting_id: Bytes<32>): [] {
    const organizer_public_key = public_key(local_secret_key());

    assert (prove_eligibility(),
        "Not authorized");    

    assert (voting_organizers.lookup(disclose(voting_id)) == organizer_public_key,
        "Not authorized");       

    const current_voting_state = voting_states.lookup(disclose(voting_id));

    assert (current_voting_state == VOTE_STATE.closed,
        "Voting phase is not closed or has already opened");
    
    voting_states.insert(disclose(voting_id), VOTE_STATE.open);
}


// Function to cast a vote, only accessible when voting is open and the voter hasn’t already voted
export circuit cast_vote(voting_id: Bytes<32>): [] {
    const current_voting_state = voting_states.lookup(disclose(voting_id));
    const current_expiration_time = cast_vote_expiration_time.lookup(disclose(voting_id));
    assert (blockTimeLte(disclose(current_expiration_time)),
        "The deadline for vote casting has expired");

    assert (current_voting_state == VOTE_STATE.open, 
        "Voting is not open");

    const voter_public_key = disclose(public_key(local_secret_key()));

    assert (prove_eligibility(), 
        "Not authorized!");

    const voting_nullifier = disclose(nullifier(local_secret_key(), voting_id));

    // Έλεγχος αν ο nullifier για τον τρέχον χρήστη ανήκει στο σύνολο. Αν ανήκει σημαίνει ότι έχει ήδη ψηφίσει
    assert (!voting_nulifiers.lookup(disclose(voting_id)).member(voting_nullifier),
        "Already voted for this voting");

    voting_nulifiers.lookup(disclose(voting_id)).insert(disclose(voting_nullifier));
    const hashed_vote = disclose(hash_secret_vote(secret_vote(voting_id), voting_id, local_secret_key()));
    hashed_votes.lookup(disclose(voting_id)).insert(disclose(hashed_vote));

    // assert (voting_options.lookup(disclose(voting_id)).member(disclose(vote_option)),
    //     "Not a valid option!");

    // voting_results.lookup(disclose(voting_id)).lookup(disclose(vote_option)).increment(1);

}

export circuit publish_vote(voting_id: Bytes<32>): [] {
    const current_voting_state = voting_states.lookup(disclose(voting_id));

    const current_publish_expiration_time = publish_vote_expiration_time.lookup(disclose(voting_id));
    assert (blockTimeLte(disclose(current_publish_expiration_time)),
        "The deadline for vote publishing has expired");

    const current_cast_expiration_time = cast_vote_expiration_time.lookup(disclose(voting_id));    
    assert (blockTimeGt(disclose(current_cast_expiration_time)),
        "The deadline for vote casting has not expired yet");

    assert (current_voting_state == VOTE_STATE.open, 
        "Voting is not open");

    assert (prove_eligibility(), 
        "Not authorized!");   

    const publish_voting_nullifier = disclose(publish_nullifier(local_secret_key(), voting_id));

    // Έλεγχος αν ο nullifier για τον τρέχον χρήστη ανήκει στο σύνολο. Αν ανήκει σημαίνει ότι έχει ήδη ψηφίσει
    assert (!publish_voting_nulifiers.lookup(disclose(voting_id)).member(publish_voting_nullifier),
        "Already published the vote for this voting");    

    const hashed_vote = disclose(hash_secret_vote(secret_vote(voting_id), voting_id, local_secret_key()));

    assert (hashed_votes.lookup(disclose(voting_id)).member(disclose(hashed_vote)),
        "Vote not correct!");     

    assert (voting_options.lookup(disclose(voting_id)).member(disclose(secret_vote(voting_id))),
        "Not a valid option!");

    voting_results.lookup(disclose(voting_id)).lookup(disclose(secret_vote(voting_id))).increment(1);
    publish_voting_nulifiers.lookup(disclose(voting_id)).insert(publish_voting_nullifier);

}


// Function to compute a public key for a voter based on secret key
circuit public_key(sk: Bytes<32>): Bytes<32> {
    return persistentHash<Bytes<32>>(sk);
}

circuit nullifier (sk: Bytes<32>, voting_id: Bytes<32>): Bytes<32> {
   return persistentHash<Vector<3, Bytes<32>>>(
           [pad(32, "nulifier-domain"), voting_id as Bytes<32>, sk]);
}

circuit publish_nullifier (sk: Bytes<32>, voting_id: Bytes<32>): Bytes<32> {
   return persistentHash<Vector<3, Bytes<32>>>(
           [pad(32, "publish-nulifier-domain"), voting_id as Bytes<32>, sk]);
}

circuit generate_voting_id (count: Field, sk: Bytes<32>) : Bytes<32> {
    return persistentHash<Vector<3, Bytes<32>>>(
           [pad(32, "generate_id"), count as Bytes<32>, sk]);
}

circuit hash_secret_vote(
    secret_vote: Bytes<32>, 
    voting_id: Bytes<32>, 
    secret_key: Bytes<32>
): Bytes<32> {
    return persistentHash<Vector<4, Bytes<32>>>(
        [pad(32, "secret-vote-domain"), voting_id, secret_vote, secret_key]
    );
}